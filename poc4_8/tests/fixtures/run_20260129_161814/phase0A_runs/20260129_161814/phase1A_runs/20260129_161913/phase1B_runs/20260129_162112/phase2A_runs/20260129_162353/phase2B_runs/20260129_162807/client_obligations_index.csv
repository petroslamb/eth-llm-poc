"id","category","enforcement_type","statement","locations","code_flow","obligation_gap","code_gap","client_locations","client_code_flow","client_obligation_gap","client_code_gap"
"EIP2930-OBL-001","tx validation","format constraint","EIP-2930 transactions MUST use TransactionType 1.","[transactions.py:L224, transactions.py:L238-L240, exceptions.py:L10-L24]","apply_body() -> decode_transaction(tx) -> if tx[0] != 1 -> raises TransactionTypeError(tx[0]). Entry point: fork.py:apply_body():L475 calls decode_transaction() on each transaction. Enforcement: transactions.py:L238-L239 checks tx[0] != 1 and raises TransactionTypeError.","","","[core/types/transaction.go:L46-L53, core/types/transaction.go:L206-L208, core/types/transaction.go:L215-L216, core/types/tx_access_list.go:L99]","Transaction.decodeTyped():L201-L220 switches on first byte b[0]. For type 0x01 (AccessListTxType constant at L49), creates AccessListTx (L207-L208) and calls decode(). AccessListTx.txType():L99 returns AccessListTxType. Enforcement: L215-L216 returns ErrTxTypeNotSupported for unknown types.","",""
"EIP2930-OBL-002","tx validation","format constraint","The EIP-2718 TransactionPayload for type 1 transactions MUST be rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, signatureYParity, signatureR, signatureS]).","[transactions.py:L137-L204, transactions.py:L223-L224, transactions.py:L240]","decode_transaction(tx) -> rlp.decode_to(AccessListTransaction, tx[1:]). Entry point: fork.py:apply_body():L475 -> decode_transaction() -> transactions.py:L240 decodes to AccessListTransaction dataclass (L137-L204). RLP decode will fail if structure doesn't match. Enforcement: rlp.decode_to() raises RLPDecodingError if field count/types don't match AccessListTransaction schema.","","","[core/types/tx_access_list.go:L47-L58, core/types/tx_access_list.go:L127-L129, core/types/tx_access_list.go:L123-L125]","AccessListTx struct (L47-L58) defines RLP schema: ChainID, Nonce, GasPrice, Gas (gasLimit), To, Value, Data, AccessList, V (yParity), R, S. Entry: tx_access_list.go:decode():L127-L129 calls rlp.DecodeBytes(input, tx). Encoding: encode():L123-L125 calls rlp.Encode(). Enforcement: RLP library validates struct field count and types match during decode; mismatches cause decode error.","",""
"EIP2930-OBL-003","tx validation","signature validation","The signature elements (signatureYParity, signatureR, signatureS) MUST represent a secp256k1 signature over keccak256(0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList])).","[transactions.py:L358-L363, transactions.py:L418-L441, transactions.py:L336-L340]","check_transaction() -> recover_sender(chain_id, tx) -> validates r/s range (L336-L340) -> secp256k1_recover(r, s, y_parity, signing_hash_2930(tx)). Entry point: fork.py:check_transaction():L388 -> recover_sender() -> transactions.py:L358-L363 (for AccessListTransaction). signing_hash_2930():L418-L441 computes keccak256(0x01 || rlp([...])). Enforcement: InvalidSignatureError raised if r/s invalid or signature recovery fails.","","","[core/types/tx_access_list.go:L131-L144, core/types/hashing.go:L68-L76, core/types/transaction_signing.go:L254-L270, crypto/crypto.go:L240-L251]","AccessListTx.sigHash():L131-L144 calls prefixedRlpHash(AccessListTxType, [...fields...]). prefixedRlpHash():L68-L76 writes type byte 0x01 then RLP-encodes fields, computes keccak256. modernSigner.Sender():L254-L270 calls recoverPlain() with V+27, R, S via Hash(tx). Enforcement: crypto.ValidateSignatureValues():L240-L251 validates v in {0,1}, r in [1,N), s in [1,N/2) for homestead. recoverPlain returns ErrInvalidSig on failure.","",""
"EIP2930-OBL-004","tx validation","format constraint","The EIP-2718 ReceiptPayload for type 1 transactions MUST be rlp([status, cumulativeGasUsed, logsBloom, logs]).","[blocks.py:L238-L268, blocks.py:L270-L281]","make_receipt(tx, ...) -> encode_receipt(tx, receipt). Entry point: fork.py:process_transaction():L715-L716 -> make_receipt() -> fork.py:L439 -> encode_receipt(). Enforcement: blocks.py:L270-L281 encode_receipt() prefixes with 0x01 and RLP encodes the Receipt dataclass (L238-L268). Receipt structure matches spec: succeeded(status), cumulative_gas_used, bloom, logs.","","","[core/types/receipt.go:L90-L96, core/types/receipt.go:L123-L135, core/types/receipt.go:L138-L141]","receiptRLP struct:L90-L96 defines [PostStateOrStatus, CumulativeGasUsed, Bloom, Logs]. Receipt.EncodeRLP():L123-L135 creates receiptRLP, calls encodeTyped() for non-legacy. encodeTyped():L138-L141 writes r.Type byte (0x01 for AccessListTxType) then RLP-encodes receiptRLP. Enforcement: Type byte prefix matches tx type; RLP structure enforced by receiptRLP struct definition.","",""
"EIP2930-OBL-005","tx validation","format constraint","For the transaction to be valid, accessList MUST be of type [[{20 bytes}, [{32 bytes}...]]...] (a list of [address, storage_keys] pairs where address is 20 bytes and each storage key is 32 bytes).","[transactions.py:L116-L133, transactions.py:L185]","decode_transaction() -> rlp.decode_to(AccessListTransaction, ...). AccessListTransaction.access_list is Tuple[Access, ...] (L185) where Access contains 'account: Address' (20 bytes) and 'slots: Tuple[Bytes32, ...]' (32 bytes each). Enforcement: RLP decoding to Access dataclass enforces Address=20 bytes via type, Bytes32=32 bytes via type. Implicit via ethereum_types type constraints.","","RLP decode relies on ethereum_types type validation; explicit length checks not visible in code. Access class at L116-L133 defines structure but actual byte-length enforcement is delegated to ethereum_types/RLP library.","[core/types/tx_access_list.go:L29-L36, common/types.go:L39-L41, common/types.go:L56, common/types.go:L221-L222]","AccessList=[]AccessTuple (L30). AccessTuple:L33-L36 has Address (common.Address) and StorageKeys ([]common.Hash). common.Address:L221-L222 is [AddressLength]byte where AddressLength=20 (L41). common.Hash:L56 is [HashLength]byte where HashLength=32 (L39). Entry: tx_access_list.go:decode() via RLP. Enforcement: Go array types enforce exact sizes; RLP decode fails if byte lengths mismatch.","",""
"EIP2930-OBL-006","tx validation","format constraint","Each item in the accessList MUST be a list of exactly 2 elements.","[transactions.py:L116-L133]","decode_transaction() -> rlp.decode_to(AccessListTransaction, ...) -> decodes access_list to Tuple[Access, ...]. Access dataclass (L116-L133) has exactly 2 fields: account and slots. Enforcement: RLP decode_to() enforces structure match with Access dataclass having 2 fields.","","Enforcement implicit via RLP decode to Access dataclass. No explicit 2-element check visible in code; relies on RLP library behavior.","[core/types/tx_access_list.go:L33-L36]","AccessTuple struct:L33-L36 has exactly 2 fields: Address and StorageKeys. Entry: RLP decode of AccessList via tx_access_list.go:decode(). Enforcement: RLP library decodes to struct with 2 fields; extra/missing fields cause decode error per RLP encoding rules.","",""
"EIP2930-OBL-007","tx validation","format constraint","Each address in the accessList MUST be exactly 20 bytes.","[transactions.py:L124]","decode_transaction() -> rlp.decode_to() -> Access.account: Address. Address is defined as 20-byte type. Enforcement: transactions.py:L124 declares 'account: Address' where Address is Bytes20.","","Length enforcement via Address type definition (Bytes20). Not an explicit length check in transactions.py.","[core/types/tx_access_list.go:L34, common/types.go:L41, common/types.go:L221-L222]","AccessTuple.Address:L34 is common.Address type. common.Address:L221-L222 defined as [AddressLength]byte. AddressLength=20 (types.go:L41). Entry: RLP decode. Enforcement: Go's fixed-size array [20]byte enforces exact 20-byte size; RLP library rejects mismatched lengths.","",""
"EIP2930-OBL-008","tx validation","format constraint","The storage keys element of each accessList item MUST be a list.","[transactions.py:L129]","decode_transaction() -> rlp.decode_to() -> Access.slots: Tuple[Bytes32, ...]. Enforcement: transactions.py:L129 declares 'slots: Tuple[Bytes32, ...]' - a tuple type.","","Enforcement via type annotation Tuple[...]. No explicit isinstance(slots, list) check.","[core/types/tx_access_list.go:L35]","AccessTuple.StorageKeys:L35 is []common.Hash, a Go slice type. Entry: RLP decode. Enforcement: RLP library decodes as list of Hash items; non-list input causes decode error.","",""
"EIP2930-OBL-009","tx validation","format constraint","Each storage key in the accessList MUST be exactly 32 bytes.","[transactions.py:L129]","decode_transaction() -> rlp.decode_to() -> Access.slots: Tuple[Bytes32, ...]. Enforcement: transactions.py:L129 declares slots as Tuple[Bytes32, ...] where Bytes32 enforces 32-byte length.","","Length enforcement via Bytes32 type. Not an explicit length check.","[core/types/tx_access_list.go:L35, common/types.go:L39, common/types.go:L56]","StorageKeys is []common.Hash. common.Hash:L56 is [HashLength]byte. HashLength=32 (types.go:L39). Entry: RLP decode. Enforcement: Go's fixed-size array [32]byte enforces exact 32-byte size per element; RLP library rejects mismatched lengths.","",""
"EIP2930-OBL-010","fees","gas charging","ACCESS_LIST_ADDRESS_COST (2400 gas) MUST be charged for each address in the access list.","[transactions.py:L47-L49, transactions.py:L312-L314]","validate_transaction() -> calculate_intrinsic_cost(tx). Entry point: fork.py:process_transaction():L638 -> validate_transaction() -> calculate_intrinsic_cost():L276-L319. Enforcement: transactions.py:L312-L314 adds TX_ACCESS_LIST_ADDRESS_COST (2400, defined L47-L49) for each access in tx.access_list.","","","[core/state_transition.go:L109-L110, params/protocol_params.go:L99]","IntrinsicGas():L71-L117 calculates intrinsic gas. L109-L110: gas += uint64(len(accessList)) * params.TxAccessListAddressGas. TxAccessListAddressGas=2400 (protocol_params.go:L99). Entry: state_transition.go:execute():L446 calls IntrinsicGas(). Enforcement: Access list address cost included in intrinsic gas; tx rejected at L450-L451 if gasRemaining < gas.","",""
"EIP2930-OBL-011","fees","gas charging","ACCESS_LIST_STORAGE_KEY_COST (1900 gas) MUST be charged for each storage key in the access list.","[transactions.py:L52-L55, transactions.py:L315-L317]","validate_transaction() -> calculate_intrinsic_cost(tx). Entry point: fork.py:process_transaction():L638 -> validate_transaction() -> calculate_intrinsic_cost():L276-L319. Enforcement: transactions.py:L315-L317 adds ulen(access.slots) * TX_ACCESS_LIST_STORAGE_KEY_COST (1900, defined L52-L55).","","","[core/state_transition.go:L111, core/types/tx_access_list.go:L38-L45, params/protocol_params.go:L100]","IntrinsicGas():L111 adds uint64(accessList.StorageKeys()) * params.TxAccessListStorageKeyGas. TxAccessListStorageKeyGas=1900 (protocol_params.go:L100). AccessList.StorageKeys():L38-L45 iterates tuples and sums len(tuple.StorageKeys). Entry: state_transition.go:execute():L446. Enforcement: Storage key cost included in intrinsic gas calculation; insufficient gas causes rejection.","",""
"EIP2930-OBL-012","fees","gas charging","The access list gas charge MUST occur at the beginning of execution (at the same time as the intrinsic gas is charged according to EIP-2028 rules).","[transactions.py:L276-L319, fork.py:L638, transactions.py:L268-L270]","Entry point: fork.py:process_transaction():L638 calls validate_transaction() BEFORE execution. validate_transaction():L268-L270 calls calculate_intrinsic_cost() which includes access_list_cost in total intrinsic_gas (L311-L317). Gas deducted from tx.gas at L648 (gas = tx.gas - intrinsic_gas) before message execution.","","","[core/state_transition.go:L446, core/state_transition.go:L466, core/state_transition.go:L493, core/state_transition.go:L499-L523]","execute():L446 calls IntrinsicGas() which includes access list gas (L109-L111). L466: st.gasRemaining -= gas deducts total intrinsic gas. L493: st.state.Prepare() initializes access list. L499-L523: vm.Create/vm.Call execution starts. Enforcement: Gas deducted at L466 BEFORE execution starts at L499-L523, ensuring access list charged at execution start per spec.","",""
"EIP2930-OBL-013","execution semantics","state initialization","Addresses from the access list MUST be immediately loaded into the accessed_addresses global set at the beginning of execution.","[fork.py:L657-L661, utils/message.py:L49-L52, vm/__init__.py:L90, vm/interpreter.py:L242]","Entry point: fork.py:process_transaction():L657-L663 extracts access_list_addresses from tx.access_list. fork.py:L669 passes to TransactionEnvironment. prepare_message():L49-L52 adds tx_env.access_list_addresses to accessed_addresses. Message created with accessed_addresses (L87). vm/interpreter.py:L242 initializes Evm.accessed_addresses from message.accessed_addresses.","","","[core/state/statedb.go:L1411-L1436, core/state/statedb.go:L1428-L1429, core/state_transition.go:L493]","state_transition.go:execute():L493 calls st.state.Prepare(rules, msg.From, coinbase, msg.To, precompiles, msg.AccessList). StateDB.Prepare():L1411-L1436 initializes access list under rules.IsEIP2929. L1428-L1429: for each el in list, al.AddAddress(el.Address). Enforcement: Access list addresses added at transaction start before vm.Create/Call at L499-L523.","",""
"EIP2930-OBL-014","execution semantics","state initialization","Storage keys from the access list MUST be immediately loaded into the accessed_storage_keys global set at the beginning of execution (as address-key pairs).","[fork.py:L657-L663, utils/message.py:L88, vm/__init__.py:L91, vm/interpreter.py:L243]","Entry point: fork.py:process_transaction():L657-L663 extracts (account, slot) pairs into access_list_storage_keys. fork.py:L670 passes to TransactionEnvironment. prepare_message():L88 sets accessed_storage_keys from tx_env. vm/interpreter.py:L243 initializes Evm.accessed_storage_keys from message.accessed_storage_keys.","","","[core/state/statedb.go:L1428-L1432, core/state/access_list.go:L89-L107, core/state_transition.go:L493]","state_transition.go:execute():L493 calls Prepare() with msg.AccessList. StateDB.Prepare():L1428-L1432 iterates list, calls al.AddAddress(el.Address) and for each key: al.AddSlot(el.Address, key). access_list.go:AddSlot():L89-L107 stores (address,slot) pair in slots map. Enforcement: Storage keys loaded as address-key pairs at transaction start before execution.","",""
"EIP2930-OBL-015","fees","gas charging","Non-unique addresses and storage keys in the access list MUST be charged for multiple times.","[transactions.py:L311-L317]","calculate_intrinsic_cost():L311-L317 iterates over tx.access_list without deduplication. For-loop at L313 processes 'for access in tx.access_list' meaning duplicate addresses are charged. ulen(access.slots) at L316 counts all slots including duplicates. Enforcement: No set() or deduplication applied before gas calculation.","","","[core/state_transition.go:L109-L111, core/types/tx_access_list.go:L38-L45]","IntrinsicGas():L109-L111 uses len(accessList) and accessList.StorageKeys() without deduplication. StorageKeys():L38-L45 sums len(tuple.StorageKeys) for all tuples. Entry: state_transition.go:execute():L446. Enforcement: No set/dedup before counting; duplicate addresses/keys each incur separate gas cost as specified.","",""
"EIP2930-OBL-016","fees","implicit exclusion","The access list MUST NOT be charged per-byte fees like transaction data.","[transactions.py:L298-L305, transactions.py:L311-L317]","calculate_intrinsic_cost():L298-L305 calculates data_cost from tx.data bytes only. L311-L317 calculates access_list_cost separately using fixed per-address and per-key costs. Enforcement: access_list is NOT included in the byte-by-byte iteration at L300-L304; it has its own separate cost calculation.","","","[core/state_transition.go:L81-L99, core/state_transition.go:L109-L112]","IntrinsicGas():L81-L99 iterates msg.Data bytes counting zero/non-zero for data gas. L109-L112 calculates access list cost separately via len(accessList) and StorageKeys() with fixed TxAccessListAddressGas/TxAccessListStorageKeyGas. Enforcement: Data iteration at L81-L99 processes only msg.Data; accessList uses fixed per-item costs, not byte counting.","",""
"EIP2930-OBL-017","block validation","fork activation","Type 1 transactions with access lists MUST only be valid as of FORK_BLOCK 12244000.","[]","No explicit block number check visible in berlin/fork.py. The fork mechanism relies on the execution-specs directory structure where different forks have separate implementations.","","Spec requires fork activation at block 12244000, but code uses directory-based fork selection rather than block number checks within code.","[params/config.go:L56, params/config.go:L781-L783, core/txpool/validation.go:L75-L77]","MainnetChainConfig.BerlinBlock=big.NewInt(12_244_000) (config.go:L56). ChainConfig.IsBerlin():L781-L783 calls isBlockForked(c.BerlinBlock, num). ValidateTransaction():L75-L77 checks !rules.IsBerlin && tx.Type() != LegacyTxType, returns ErrTxTypeNotSupported. Entry: txpool/validation.go:L61. Enforcement: Type 1 tx explicitly rejected before Berlin fork block via IsBerlin check.","",""
"EIP2930-OBL-018","tx validation","format constraint","The transaction MUST only be valid on networks with the specified chainID.","[transactions.py:L148, fork.py:L388]","check_transaction() -> recover_sender(chain_id, tx). Entry point: fork.py:L388 passes block_env.chain_id to recover_sender(). For AccessListTransaction at L358-L363, signing_hash_2930(tx) at L362 includes tx.chain_id in hash. If tx.chain_id != block_env.chain_id, signature recovery will fail. Enforcement: Implicit via signature verification - wrong chain_id produces wrong hash, signature won't match, InvalidSignatureError raised.","","Chain ID validation is implicit via signature verification. No explicit tx.chain_id == block_env.chain_id check found. If sender signed with different chain_id, secp256k1_recover will return wrong address, but no explicit error for chain mismatch.","[core/types/transaction_signing.go:L262-L263, core/types/tx_access_list.go:L131-L144]","modernSigner.Sender():L262-L263 explicitly checks tx.ChainId().Cmp(s.chainID) != 0, returns fmt.Errorf with ErrInvalidChainId. sigHash():L131-L144 includes chainID in signature hash. Entry: types.Sender() called during transaction validation. Enforcement: EXPLICIT chain ID mismatch check at L262-L263 provides clear error; also implicit via signature verification with chainID in hash.","",""
"EIP2930-OBL-019","tx validation","format constraint","YParity MUST be 0 for even or 1 for odd y-value of the secp256k1 signature.","[transactions.py:L359-L360, transactions.py:L191]","recover_sender() for AccessListTransaction. Entry point: fork.py:check_transaction():L388 -> recover_sender() -> transactions.py:L358-L363. Enforcement: L359-L360 checks 'if tx.y_parity not in (U256(0), U256(1)): raise InvalidSignatureError(""bad y_parity"")'. y_parity field defined at L191.","","","[crypto/crypto.go:L240-L251, core/types/transaction_signing.go:L267-L269]","modernSigner.Sender():L267-L268 retrieves V from tx.RawSignatureValues(), adds 27 (V = new(big.Int).Add(V, big.NewInt(27))). recoverPlain():L483 converts back (V := byte(Vb.Uint64() - 27)). ValidateSignatureValues():L250 checks (v == 0 || v == 1) at end of validation. Entry: types.Sender(). Enforcement: V (yParity) must be 0 or 1; ValidateSignatureValues returns false for other values, causing signature recovery failure.","",""
