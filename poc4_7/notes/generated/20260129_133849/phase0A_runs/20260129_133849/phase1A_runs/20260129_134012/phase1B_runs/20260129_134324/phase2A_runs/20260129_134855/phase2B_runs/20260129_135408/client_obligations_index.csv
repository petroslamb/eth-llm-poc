"id","category","enforcement_type","statement","locations","code_flow","obligation_gap","code_gap","client_locations","client_code_flow","client_obligation_gap","client_code_gap"
"EIP1559-OBL-001","execution semantics","opcode behavior","The GASPRICE (0x3a) opcode MUST return the effective_gas_price as defined in the reference implementation.","[vm/instructions/environment.py:gasprice, vm/__init__.py:TransactionEnvironment.gas_price, fork.py:check_transaction]","state_transition() -> apply_body() -> process_transaction() -> check_transaction() computes effective_gas_price; TransactionEnvironment.gas_price is set to effective_gas_price; gasprice opcode in environment.py:304-324 pushes evm.message.tx_env.gas_price to stack","","","[core/vm/instructions.go:L419-L423:opGasprice, core/state_transition.go:L176-L199:TransactionToMessage, core/state_transition.go:L193-L199:effectiveGasPrice computation]","TransactionToMessage() at L193-199 computes effective gas price: msg.GasPrice = min(gasTipCap, gasFeeCap-baseFee) + baseFee (capped at gasFeeCap); opGasprice() at L419-423 reads evm.GasPrice (set from msg.GasPrice via NewEVMTxContext) and pushes to stack via uint256.FromBig()","",""
"EIP1559-OBL-002","tx validation","transaction type detection","As of FORK_BLOCK_NUMBER, a new EIP-2718 transaction is introduced with TransactionType 2.","[transactions.py:FeeMarketTransaction, transactions.py:decode_transaction, transactions.py:encode_transaction, __init__.py:FORK_CRITERIA]","decode_transaction() at transactions.py:309-325 checks tx[0]==2 and returns FeeMarketTransaction; encode_transaction() at transactions.py:291-306 prefixes with b'\x02'; FORK_CRITERIA in __init__.py:48 sets ByBlockNumber(12965000)","","","[core/types/transaction.go:L50:DynamicFeeTxType=0x02, core/types/transaction.go:L200-L220:decodeTyped, core/types/tx_dynamic_fee.go:L28-L43:DynamicFeeTx, core/txpool/validation.go:L79-L81:London check]","DynamicFeeTxType=0x02 defined at transaction.go:L50; decodeTyped() at L200-220 switches on first byte, instantiates DynamicFeeTx for type 2; Transaction.UnmarshalBinary() at L178-198 handles EIP-2718 envelope; txpool ValidateTransaction() rejects type 2 if !rules.IsLondon","",""
"EIP1559-OBL-003","fees","intrinsic gas calculation","The intrinsic cost of the new transaction type 2 is 21000 + 16 * non-zero calldata bytes + 4 * zero calldata bytes + 1900 * access list storage key count + 2400 * access list address count.","[transactions.py:calculate_intrinsic_cost, transactions.py:TX_BASE_COST, transactions.py:TX_DATA_COST_PER_NON_ZERO, transactions.py:TX_DATA_COST_PER_ZERO, transactions.py:TX_ACCESS_LIST_STORAGE_KEY_COST, transactions.py:TX_ACCESS_LIST_ADDRESS_COST]","calculate_intrinsic_cost() at transactions.py:359-402 sums TX_BASE_COST(21000) + data_cost (16/4 per byte) + access_list_cost (2400 per address, 1900 per slot)","","","[core/state_transition.go:L70-L117:IntrinsicGas, params/protocol_params.go:L38:TxGas=21000, params/protocol_params.go:L96:TxDataNonZeroGasEIP2028=16, params/protocol_params.go:L40:TxDataZeroGas=4, params/protocol_params.go:L99-L100:TxAccessListAddressGas=2400/TxAccessListStorageKeyGas=1900]","IntrinsicGas() at L70-117 computes: TxGas(21000) + nz*TxDataNonZeroGasEIP2028(16) + z*TxDataZeroGas(4) + len(accessList)*TxAccessListAddressGas(2400) + accessList.StorageKeys()*TxAccessListStorageKeyGas(1900); uses isEIP2028 flag for post-Istanbul pricing","",""
"EIP1559-OBL-004","tx validation","RLP encoding","The EIP-2718 TransactionPayload for type 2 transactions is rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list, signature_y_parity, signature_r, signature_s]).","[transactions.py:FeeMarketTransaction, transactions.py:encode_transaction]","FeeMarketTransaction dataclass at transactions.py:208-282 defines fields in spec order; encode_transaction() at transactions.py:303-304 returns b'\x02' + rlp.encode(tx)","","","[core/types/tx_dynamic_fee.go:L28-L43:DynamicFeeTx struct, core/types/tx_dynamic_fee.go:L119-L125:encode/decode, core/types/transaction.go:L124-L128:encodeTyped]","DynamicFeeTx struct at L28-43 defines fields: ChainID, Nonce, GasTipCap, GasFeeCap, Gas, To, Value, Data, AccessList, V, R, S (matching EIP-1559 order); encode() at L119-121 calls rlp.Encode(b, tx); encodeTyped() at transaction.go:L124-128 writes type byte then inner.encode()","",""
"EIP1559-OBL-005","tx validation","signature verification","The signature_y_parity, signature_r, signature_s elements of a type 2 transaction represent a secp256k1 signature over keccak256(0x02 || rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list])).","[transactions.py:signing_hash_1559, transactions.py:recover_sender]","signing_hash_1559() at transactions.py:533-557 computes keccak256(b'\x02' + rlp.encode(...)); recover_sender() at transactions.py:447-452 uses secp256k1_recover with signing_hash_1559(tx)","","","[core/types/tx_dynamic_fee.go:L127-L141:sigHash, core/types/transaction_signing.go:L134-L157:Sender, core/types/hashing.go:prefixedRlpHash]","sigHash() at L127-141 computes prefixedRlpHash(DynamicFeeTxType, [chainID, Nonce, GasTipCap, GasFeeCap, Gas, To, Value, Data, AccessList]) = keccak256(0x02 || rlp([...])); Sender() at transaction_signing.go:L141-157 recovers address via signer.Sender() using signature values and cached sigCache","",""
"EIP1559-OBL-006","tx validation","receipt encoding","The EIP-2718 ReceiptPayload for type 2 transactions is rlp([status, cumulative_transaction_gas_used, logs_bloom, logs]).","[blocks.py:Receipt, blocks.py:encode_receipt]","Receipt dataclass at blocks.py:262-291 defines succeeded, cumulative_gas_used, bloom, logs; encode_receipt() at blocks.py:294-308 returns b'\x02' + rlp.encode(receipt) for FeeMarketTransaction","","","[core/types/receipt.go:L90-L96:receiptRLP struct, core/types/receipt.go:L137-L141:encodeTyped, core/types/receipt.go:L202-L218:decodeTyped]","receiptRLP struct at L90-96 contains PostStateOrStatus, CumulativeGasUsed, Bloom, Logs; encodeTyped() at L137-141 writes type byte followed by rlp.Encode(w, data); decodeTyped() at L202-218 handles DynamicFeeTxType case","",""
"EIP1559-OBL-007","block validation","header validation","A block's gas_used must not exceed its gas_limit.","[fork.py:validate_header:L320-L321]","validate_header() at fork.py:320-321 checks if header.gas_used > header.gas_limit and raises InvalidBlock","","","[consensus/misc/eip1559/eip1559.go:L33-L53:VerifyEIP1559Header, consensus/misc/gaslimit.go:L27-L41:VerifyGaslimit]","VerifyEIP1559Header() at L33-53 calls misc.VerifyGaslimit() which validates gas limit bounds; block gasUsed vs gasLimit validation occurs during block processing in state_processor.go when GasPool is depleted","","Implicit validation: gasUsed exceeding gasLimit causes GasPool exhaustion error rather than explicit header check"
"EIP1559-OBL-008","block validation","gas limit bounds","A block's gas_limit must be less than parent_gas_limit + parent_gas_limit // 1024.","[fork.py:check_gas_limit:L884-L886, fork.py:GAS_LIMIT_ADJUSTMENT_FACTOR]","check_gas_limit() at fork.py:884-886 computes max_adjustment_delta = parent_gas_limit // GAS_LIMIT_ADJUSTMENT_FACTOR(1024) and returns False if gas_limit >= parent_gas_limit + max_adjustment_delta","","","[consensus/misc/gaslimit.go:L27-L41:VerifyGaslimit, params/protocol_params.go:L26:GasLimitBoundDivisor=1024]","VerifyGaslimit() at L27-41 computes limit = parentGasLimit / GasLimitBoundDivisor(1024); at L34 returns error if uint64(diff) >= limit (i.e., abs(gasLimit - parent) >= parent/1024, which enforces strict < bound)","",""
"EIP1559-OBL-009","block validation","gas limit bounds","A block's gas_limit must be greater than parent_gas_limit - parent_gas_limit // 1024.","[fork.py:check_gas_limit:L887-L888, fork.py:GAS_LIMIT_ADJUSTMENT_FACTOR]","check_gas_limit() at fork.py:887-888 returns False if gas_limit <= parent_gas_limit - max_adjustment_delta","","","[consensus/misc/gaslimit.go:L27-L41:VerifyGaslimit, params/protocol_params.go:L26:GasLimitBoundDivisor=1024]","VerifyGaslimit() at L27-41 computes diff = abs(parent - header) and limit = parent/1024; returns error if diff >= limit, covering both upper and lower bounds in single check","",""
"EIP1559-OBL-010","block validation","gas limit minimum","A block's gas_limit must be at least 5000.","[fork.py:check_gas_limit:L889-L890, fork.py:GAS_LIMIT_MINIMUM]","check_gas_limit() at fork.py:889-890 returns False if gas_limit < GAS_LIMIT_MINIMUM(5000)","","","[consensus/misc/gaslimit.go:L37-L40:MinGasLimit check, params/protocol_params.go:L27:MinGasLimit=5000]","VerifyGaslimit() at L37-40 checks if headerGasLimit < params.MinGasLimit(5000) and returns fmt.Errorf() with minimum gas limit violation","",""
"EIP1559-OBL-011","base fee adjustment","fork initialization","At the fork block (INITIAL_FORK_BLOCK_NUMBER), the base_fee_per_gas must equal INITIAL_BASE_FEE (1000000000 wei).","[fork.py:validate_header:L325-L326, fork.py:INITIAL_BASE_FEE]","validate_header() at fork.py:325-326 sets expected_base_fee_per_gas = INITIAL_BASE_FEE when header.number == FORK_CRITERIA.block_number; INITIAL_BASE_FEE = Uint(1000000000) at fork.py:73","","","[consensus/misc/eip1559/eip1559.go:L56-L60:CalcBaseFee fork check, params/protocol_params.go:L135:InitialBaseFee=1000000000]","CalcBaseFee() at L56-60: if !config.IsLondon(parent.Number) returns new(big.Int).SetUint64(params.InitialBaseFee) where InitialBaseFee=1000000000; this correctly returns initial fee for first EIP-1559 block","",""
"EIP1559-OBL-012","base fee adjustment","base fee calculation","When parent_gas_used equals parent_gas_target, the expected_base_fee_per_gas equals parent_base_fee_per_gas.","[fork.py:calculate_base_fee_per_gas:L252-L253]","calculate_base_fee_per_gas() at fork.py:252-253 checks if parent_gas_used == parent_gas_target and returns parent_base_fee_per_gas","","","[consensus/misc/eip1559/eip1559.go:L62-L66:CalcBaseFee target check]","CalcBaseFee() at L62-66 computes parentGasTarget = parent.GasLimit / config.ElasticityMultiplier(); at L64-66 if parent.GasUsed == parentGasTarget, returns new(big.Int).Set(parent.BaseFee) unchanged","",""
"EIP1559-OBL-013","base fee adjustment","base fee calculation","When parent_gas_used exceeds parent_gas_target, the base_fee_per_gas must increase by max(parent_base_fee_per_gas * gas_used_delta // parent_gas_target // BASE_FEE_MAX_CHANGE_DENOMINATOR, 1).","[fork.py:calculate_base_fee_per_gas:L254-L267, fork.py:BASE_FEE_MAX_CHANGE_DENOMINATOR]","calculate_base_fee_per_gas() at fork.py:254-267 computes gas_used_delta, then base_fee_per_gas_delta = max(parent_base_fee_per_gas * gas_used_delta // parent_gas_target // BASE_FEE_MAX_CHANGE_DENOMINATOR(8), 1)","","","[consensus/misc/eip1559/eip1559.go:L73-L83:CalcBaseFee increase path, params/protocol_params.go:L133:DefaultBaseFeeChangeDenominator=8]","CalcBaseFee() at L73-83: when parent.GasUsed > parentGasTarget, computes num = (gasUsed-target) * baseFee / target / BaseFeeChangeDenominator(8); at L80-81 if num < 1 returns parent.BaseFee + 1, else returns parent.BaseFee + num (enforces min increase of 1)","",""
"EIP1559-OBL-014","base fee adjustment","base fee calculation","When parent_gas_used is below parent_gas_target, the base_fee_per_gas must decrease by parent_base_fee_per_gas * gas_used_delta // parent_gas_target // BASE_FEE_MAX_CHANGE_DENOMINATOR.","[fork.py:calculate_base_fee_per_gas:L268-L280, fork.py:BASE_FEE_MAX_CHANGE_DENOMINATOR]","calculate_base_fee_per_gas() at fork.py:268-280 computes gas_used_delta = parent_gas_target - parent_gas_used, then subtracts base_fee_per_gas_delta from parent_base_fee_per_gas","","","[consensus/misc/eip1559/eip1559.go:L84-L97:CalcBaseFee decrease path]","CalcBaseFee() at L84-97: when parent.GasUsed < parentGasTarget, computes num = (target-gasUsed) * baseFee / target / BaseFeeChangeDenominator(8); at L92-96 returns max(0, parent.BaseFee - num) with explicit floor at 0","",""
"EIP1559-OBL-015","block validation","header validation","A block's base_fee_per_gas must match the expected_base_fee_per_gas calculated from the parent block.","[fork.py:validate_header:L336-L337, fork.py:calculate_base_fee_per_gas]","validate_header() at fork.py:336-337 calls calculate_base_fee_per_gas() and raises InvalidBlock if expected_base_fee_per_gas != header.base_fee_per_gas","","","[consensus/misc/eip1559/eip1559.go:L46-L52:VerifyEIP1559Header baseFee validation]","VerifyEIP1559Header() at L46-52 calls CalcBaseFee(config, parent) and compares with header.BaseFee; returns fmt.Errorf() with detailed mismatch info if header.BaseFee.Cmp(expectedBaseFee) != 0","",""
"EIP1559-OBL-016","tx validation","balance check","After deducting transaction.amount from signer.balance, the balance must be non-negative.","[fork.py:check_transaction:L513-L514]","check_transaction() at fork.py:513-514 checks Uint(sender_account.balance) < max_gas_fee + Uint(tx.value) and raises InsufficientBalanceError","","","[core/state_transition.go:L266-L308:buyGas, core/txpool/validation.go:L269-L276:ValidateTransactionWithState balance check]","buyGas() at L269-274 adds msg.Value to balanceCheck and compares with sender balance at L292-294; ValidateTransactionWithState() at L269-276 checks balance >= tx.Cost() which includes value; both ensure balance covers value transfer","",""
"EIP1559-OBL-017","tx validation","balance check","The signer's balance must be at least transaction.gas_limit * transaction.max_fee_per_gas.","[fork.py:check_transaction:L502-L514]","check_transaction() at fork.py:502-507 computes max_gas_fee = tx.gas * tx.max_fee_per_gas for FeeMarketTransaction, then at L513-514 validates sender_account.balance >= max_gas_fee + tx.value","","","[core/state_transition.go:L266-L294:buyGas balance check]","buyGas() at L270-273: balanceCheck = gasLimit * GasFeeCap when msg.GasFeeCap != nil; adds msg.Value at L274; checks state.GetBalance(from) >= balanceCheck at L292-294; ensures worst-case gas cost is covered","",""
"EIP1559-OBL-018","tx validation","fee validation","A transaction's max_fee_per_gas must be greater than or equal to block.base_fee_per_gas.","[fork.py:check_transaction:L492-L495, exceptions.py:InsufficientMaxFeePerGasError]","check_transaction() at fork.py:492-495 checks if tx.max_fee_per_gas < block_env.base_fee_per_gas and raises InsufficientMaxFeePerGasError","","","[core/state_transition.go:L341-L362:preCheck baseFee validation, core/errors.go:ErrFeeCapTooLow]","preCheck() at L359-362 checks msg.GasFeeCap.Cmp(st.evm.Context.BaseFee) < 0 and returns ErrFeeCapTooLow; skips check when NoBaseFee && GasFeeCap==0 && GasTipCap==0 (eth_call simulation)","",""
"EIP1559-OBL-019","tx validation","type constraint","A transaction's max_fee_per_gas must be less than 2^256.","[transactions.py:FeeMarketTransaction.max_fee_per_gas]","FeeMarketTransaction.max_fee_per_gas at transactions.py:235 is typed as Uint which is unbounded; constraint enforced by RLP decoding limits","Spec states < 2^256 but Uint type is unbounded","RLP decoding may allow values exceeding practical limits","[core/state_transition.go:L345-L348:preCheck GasFeeCap check, core/txpool/validation.go:L105-L106]","preCheck() at L345-348 checks if msg.GasFeeCap.BitLen() > 256 and returns ErrFeeCapVeryHigh; ValidateTransaction() at L105-106 performs same BitLen() > 256 check; enforces strict < 2^256 constraint","",""
"EIP1559-OBL-020","tx validation","type constraint","A transaction's max_priority_fee_per_gas must be less than 2^256.","[transactions.py:FeeMarketTransaction.max_priority_fee_per_gas]","FeeMarketTransaction.max_priority_fee_per_gas at transactions.py:230 is typed as Uint which is unbounded; constraint enforced by RLP decoding limits","Spec states < 2^256 but Uint type is unbounded","RLP decoding may allow values exceeding practical limits","[core/state_transition.go:L349-L352:preCheck GasTipCap check, core/txpool/validation.go:L107-L109]","preCheck() at L349-352 checks if msg.GasTipCap.BitLen() > 256 and returns ErrTipVeryHigh; ValidateTransaction() at L107-109 performs same BitLen() > 256 check; enforces strict < 2^256 constraint","",""
"EIP1559-OBL-021","tx validation","fee validation","A transaction's max_fee_per_gas must be greater than or equal to its max_priority_fee_per_gas.","[fork.py:check_transaction:L487-L491, exceptions.py:PriorityFeeGreaterThanMaxFeeError]","check_transaction() at fork.py:488-491 checks if tx.max_fee_per_gas < tx.max_priority_fee_per_gas and raises PriorityFeeGreaterThanMaxFeeError","","","[core/state_transition.go:L353-L356:preCheck tip vs feeCap, core/txpool/validation.go:L111-L114, core/errors.go:ErrTipAboveFeeCap]","preCheck() at L353-356 checks msg.GasFeeCap.Cmp(msg.GasTipCap) < 0 and returns ErrTipAboveFeeCap; ValidateTransaction() at L111-114 performs same GasFeeCapIntCmp(GasTipCap) < 0 check with same error","",""
"EIP1559-OBL-022","tx validation","balance check","After deducting gas costs from signer.balance, the balance must be non-negative.","[fork.py:check_transaction:L513-L514, fork.py:process_transaction:L772-L777]","check_transaction() validates upfront at L513-514; process_transaction() at L772-777 deducts effective_gas_fee from sender_balance_after_gas_fee","","","[core/state_transition.go:L266-L308:buyGas deduction]","buyGas() at L292-294 checks balance >= balanceCheck (gasLimit * gasFeeCap + value); at L305-306 deducts mgval = gasLimit * msg.GasPrice from sender via state.SubBalance(); non-negative enforced by prior balance check","",""
"EIP1559-OBL-023","fees","fee calculation","The priority_fee_per_gas is calculated as min(transaction.max_priority_fee_per_gas, transaction.max_fee_per_gas - block.base_fee_per_gas).","[fork.py:check_transaction:L497-L500]","check_transaction() at fork.py:497-500 computes priority_fee_per_gas = min(tx.max_priority_fee_per_gas, tx.max_fee_per_gas - block_env.base_fee_per_gas)","","","[core/state_transition.go:L193-L199:TransactionToMessage, core/types/tx_dynamic_fee.go:L100-L109:effectiveGasPrice]","TransactionToMessage() at L193-199: computes msg.GasPrice = msg.GasTipCap + baseFee, then caps at msg.GasFeeCap; effectiveGasPrice() at L100-109 computes tip = min(gasFeeCap-baseFee, gasTipCap) then adds baseFee; priority fee is implicit in the effective gas price calculation","",""
"EIP1559-OBL-024","fees","fee calculation","The effective_gas_price is calculated as priority_fee_per_gas + block.base_fee_per_gas.","[fork.py:check_transaction:L501]","check_transaction() at fork.py:501 computes effective_gas_price = priority_fee_per_gas + block_env.base_fee_per_gas","","","[core/state_transition.go:L193-L199:TransactionToMessage effectiveGasPrice, core/types/tx_dynamic_fee.go:L100-L109:effectiveGasPrice method]","TransactionToMessage() at L193-199: msg.GasPrice = min(GasTipCap + baseFee, GasFeeCap); effectiveGasPrice() at L104-108 computes tip.Add(tip, baseFee) where tip = min(gasFeeCap-baseFee, gasTipCap), yielding effective_gas_price = priority_fee + baseFee","",""
"EIP1559-OBL-025","fees","balance deduction","The signer's balance must be debited by transaction.gas_limit * effective_gas_price upfront before execution.","[fork.py:process_transaction:L767-L777]","process_transaction() at fork.py:767-777 computes effective_gas_fee = tx.gas * effective_gas_price, then sets sender_balance_after_gas_fee and calls set_account_balance()","","","[core/state_transition.go:L266-L308:buyGas debit]","buyGas() at L267-268: mgval = gasLimit * msg.GasPrice (where msg.GasPrice is effectiveGasPrice); at L305-306 calls state.SubBalance(msg.From, mgvalU256, tracing.BalanceDecreaseGasBuy) to debit sender before execution","",""
"EIP1559-OBL-026","fees","refund mechanism","After transaction execution, the signer must be refunded gas_refund * effective_gas_price for unused gas.","[fork.py:process_transaction:L801-L817]","process_transaction() at fork.py:801-817 computes tx_gas_left, gas_refund_amount = tx_gas_left * effective_gas_price, then adds to sender_balance_after_refund","","","[core/state_transition.go:L653-L667:returnGas]","returnGas() at L655-658: remaining = uint256.NewInt(st.gasRemaining); remaining.Mul(remaining, uint256.MustFromBig(st.msg.GasPrice)); state.AddBalance(st.msg.From, remaining, tracing.BalanceIncreaseGasReturn); also returns gas to block GasPool at L666","",""
"EIP1559-OBL-027","fees","miner payment","The miner (block author) must receive gas_used * priority_fee_per_gas.","[fork.py:process_transaction:L810-L828]","process_transaction() at fork.py:810-811 computes priority_fee_per_gas = effective_gas_price - block_env.base_fee_per_gas; L811 computes transaction_fee = tx_gas_used_after_refund * priority_fee_per_gas; L819-828 adds to coinbase_balance","","","[core/state_transition.go:L547-L566:execute miner payment]","execute() at L547-550: effectiveTip = msg.GasPrice - baseFee (for London rules); at L558-560: fee = gasUsed * effectiveTip; state.AddBalance(Coinbase, fee, tracing.BalanceIncreaseRewardTransactionFee); skips payment when NoBaseFee && GasFeeCap==0 && GasTipCap==0","",""
"EIP1559-OBL-028","fees","fee burning","The base_fee_per_gas is burned (not given to anyone).","[fork.py:process_transaction:L810-L811]","process_transaction() at fork.py:810-811 computes transaction_fee using only priority_fee_per_gas, excluding base_fee_per_gas which is implicitly burned (never credited to any account)","","","[core/state_transition.go:L547-L566:execute fee payment]","execute() at L547-560: only effectiveTip (gasPrice - baseFee) is paid to coinbase; baseFee portion (gasUsed * baseFee) is implicitly burned by being deducted from sender in buyGas() but never credited to any account","",""
"EIP1559-OBL-029","block validation","receipt validation","The cumulative_transaction_gas_used must equal the block's gas_used field.","[fork.py:state_transition:L202-L205, blocks.py:Receipt.cumulative_gas_used]","state_transition() at fork.py:202-205 checks if block_output.block_gas_used != block.header.gas_used; Receipt.cumulative_gas_used tracks running total per-tx","","","[core/state_processor.go:L165:usedGas accumulation, core/state_processor.go:L176-L179:MakeReceipt, core/types/receipt.go:L58:CumulativeGasUsed]","ApplyTransactionWithEVM() at L165 accumulates *usedGas += result.UsedGas; MakeReceipt() at L179 sets receipt.CumulativeGasUsed = usedGas; ProcessResult at L137 returns GasUsed which must match header.GasUsed (validated by consensus)","",""
"EIP1559-OBL-030","base fee adjustment","fork transition","On the fork block, the parent_gas_target is set to parent.gas_limit (not divided by ELASTICITY_MULTIPLIER).","[fork.py:validate_header:L323-L334]","validate_header() at fork.py:325-326 uses INITIAL_BASE_FEE directly for fork block; for non-fork blocks at L329-334, calculate_base_fee_per_gas() receives parent_header.gas_limit as parent_gas_limit","Spec describes parent_gas_target handling on fork block but code uses INITIAL_BASE_FEE directly","Code does not explicitly set parent_gas_target = parent.gas_limit; handled implicitly via INITIAL_BASE_FEE","[consensus/misc/eip1559/eip1559.go:L35-L38:VerifyEIP1559Header fork transition, consensus/misc/eip1559/eip1559.go:L56-L60:CalcBaseFee fork check]","VerifyEIP1559Header() at L35-38: if !config.IsLondon(parent.Number), multiplies parentGasLimit by ElasticityMultiplier to handle pre-London parent having half the effective limit; CalcBaseFee() at L56-60 returns InitialBaseFee for first London block, bypassing target calculation","","Fork transition handles gas limit doubling in VerifyEIP1559Header but CalcBaseFee returns fixed InitialBaseFee"
"EIP1559-OBL-031","base fee adjustment","fork transition","On the fork block, the parent_gas_limit is set to parent.gas_limit * ELASTICITY_MULTIPLIER.","[fork.py:validate_header:L323-L334]","validate_header() at fork.py:325-326 uses INITIAL_BASE_FEE directly for fork block, bypassing gas limit calculation; for subsequent blocks, calculate_base_fee_per_gas() is called","Spec describes doubling parent_gas_limit on fork block but code uses INITIAL_BASE_FEE shortcut","Code does not explicitly double parent_gas_limit; handled implicitly via INITIAL_BASE_FEE","[consensus/misc/eip1559/eip1559.go:L35-L38:VerifyEIP1559Header gas limit adjustment]","VerifyEIP1559Header() at L35-38: parentGasLimit = parent.GasLimit * config.ElasticityMultiplier() when !config.IsLondon(parent.Number); this doubles the effective parent gas limit for fork transition validation","",""
"EIP1559-OBL-032","base fee adjustment","constant definition","The gas_target for a block is calculated as gas_limit // ELASTICITY_MULTIPLIER (where ELASTICITY_MULTIPLIER = 2).","[fork.py:calculate_base_fee_per_gas:L248, fork.py:ELASTICITY_MULTIPLIER]","calculate_base_fee_per_gas() at fork.py:248 computes parent_gas_target = parent_gas_limit // ELASTICITY_MULTIPLIER; ELASTICITY_MULTIPLIER = Uint(2) at fork.py:69","","","[consensus/misc/eip1559/eip1559.go:L62:CalcBaseFee target calculation, params/config.go:ElasticityMultiplier, params/protocol_params.go:L134:DefaultElasticityMultiplier=2]","CalcBaseFee() at L62: parentGasTarget = parent.GasLimit / config.ElasticityMultiplier(); config.ElasticityMultiplier() returns DefaultElasticityMultiplier(2) or chain-specific override from ChainConfig","",""
"EIP1559-OBL-033","base fee adjustment","constant definition","The BASE_FEE_MAX_CHANGE_DENOMINATOR constant equals 8.","[fork.py:BASE_FEE_MAX_CHANGE_DENOMINATOR]","BASE_FEE_MAX_CHANGE_DENOMINATOR = Uint(8) defined at fork.py:68","","","[params/protocol_params.go:L133:DefaultBaseFeeChangeDenominator=8, params/config.go:BaseFeeChangeDenominator method]","DefaultBaseFeeChangeDenominator = 8 defined at protocol_params.go:L133; config.BaseFeeChangeDenominator() returns this value or chain-specific override; used in CalcBaseFee() at eip1559.go:L79,L90","",""
"EIP1559-OBL-034","tx validation","signature validation","Transaction signature and chain ID must be validated before normalizing the transaction.","[transactions.py:recover_sender]","recover_sender() at transactions.py:405-454 validates r, s bounds, y_parity values, and chain_id matching before recovering public key; called from check_transaction() at fork.py:484","","","[core/types/transaction_signing.go:L134-L157:Sender, core/txpool/validation.go:L115-L118:signature validation, core/types/transaction.go:L231-L250:sanityCheckSignature]","Sender() at L141-157 via signer.Sender(tx) validates signature and recovers address; ValidateTransaction() at L115-118 calls types.Sender() and returns ErrInvalidSender on failure; sanityCheckSignature() at transaction.go:L231-250 validates v, r, s values and chain ID protection","",""
"EIP1559-OBL-035","tx validation","legacy tx normalization","Legacy transactions must be normalized with gas_price mapped to both max_priority_fee_per_gas and max_fee_per_gas.","[fork.py:check_transaction:L503-L507]","check_transaction() at fork.py:504-507 handles non-FeeMarketTransaction by using tx.gas_price directly as effective_gas_price, which achieves same effect as max_fee = max_priority_fee = gas_price","","","[core/types/tx_legacy.go:L100-L102:gasTipCap/gasFeeCap accessors, core/state_transition.go:L176-L199:TransactionToMessage]","LegacyTx at L100-102: gasTipCap() returns tx.GasPrice, gasFeeCap() returns tx.GasPrice; TransactionToMessage() copies these to msg.GasTipCap and msg.GasFeeCap at L181-182, effectively normalizing legacy tx with gas_price as both fee caps","",""
"EIP1559-OBL-036","tx validation","EIP-2930 tx normalization","EIP-2930 transactions must be normalized with gas_price mapped to both max_priority_fee_per_gas and max_fee_per_gas.","[fork.py:check_transaction:L503-L507]","check_transaction() at fork.py:504-507 handles AccessListTransaction same as legacy: tx.gas_price used directly as effective_gas_price","","","[core/types/tx_access_list.go:L104-L106:gasTipCap/gasFeeCap accessors, core/state_transition.go:L176-L199:TransactionToMessage]","AccessListTx at L104-106: gasTipCap() returns tx.GasPrice, gasFeeCap() returns tx.GasPrice; TransactionToMessage() copies these to msg.GasTipCap and msg.GasFeeCap, normalizing EIP-2930 tx identically to legacy transactions","",""
