# PoC 4.7 Run Summary

## Run configuration
- Run root: /home/runner/work/eth-llm-poc/eth-llm-poc/runs/ci_run
- Generated at: 20260201_231328
- EIP: 7702
- Fork: prague
- Client: geth
- Spec branch: HEAD
- Spec commit: ca18ab1cbc431f1291c58246f0ca4a53e37c7a7d
- Model: claude-opus-4-5
- Max turns: 20
- LLM mode: live
- Record LLM calls: False
- Allowed tools: Read, Write, Bash, Grep, Glob
- Obligation filter: None

## Phases
- 0A — Obligation extraction + indexing: /home/runner/work/eth-llm-poc/eth-llm-poc/runs/ci_run/phase0A_runs/20260201_230238/run_manifest.json
- 1A — Per-obligation implementation locations: /home/runner/work/eth-llm-poc/eth-llm-poc/runs/ci_run/phase0A_runs/20260201_230238/phase1A_runs/20260201_230344/run_manifest.json
- 1B — Code flow + gap hints per obligation: /home/runner/work/eth-llm-poc/eth-llm-poc/runs/ci_run/phase0A_runs/20260201_230238/phase1A_runs/20260201_230344/phase1B_runs/20260201_230513/run_manifest.json
- 2A — Client implementation locations: /home/runner/work/eth-llm-poc/eth-llm-poc/runs/ci_run/phase0A_runs/20260201_230238/phase1A_runs/20260201_230344/phase1B_runs/20260201_230513/phase2A_runs/20260201_230748/run_manifest.json
- 2B — Client gap analysis: /home/runner/work/eth-llm-poc/eth-llm-poc/runs/ci_run/phase0A_runs/20260201_230238/phase1A_runs/20260201_230344/phase1B_runs/20260201_230513/phase2A_runs/20260201_230748/phase2B_runs/20260201_231022/run_manifest.json

## Spec Map Mismatches
These are forks where execution-specs README EIP lists disagree with fork __init__ EIP lists (captured in Phase 0A).
- Count: 2
- Cancun
- Shanghai

## Spec Map Check (Phase 1A)
Phase 1A validates the selected fork against the Phase 0A EIP→fork map and reports whether the README and fork __init__ agree.
Status meanings: ok, mismatch, fork_not_found, invalid_json, missing.
```json
{
  "fork": "prague",
  "spec_map_path": "runs/ci_run/phase0A_runs/20260201_230238/eip_fork_map.json",
  "status": "ok",
  "readme_only": [],
  "fork_init_only": [],
  "mismatch": false
}
```

## Statistics (Phase 2B)
- Source: `runs/ci_run/phase0A_runs/20260201_230238/phase1A_runs/20260201_230344/phase1B_runs/20260201_230513/phase2A_runs/20260201_230748/phase2B_runs/20260201_231022/client_obligations_index.csv`
- Total Obligations: **40**

| Column | Populated | % | Progress |
|---|---|---|---|
| id | 40 | 100% | `[██████████] 100%` |
| category | 40 | 100% | `[██████████] 100%` |
| enforcement_type | 40 | 100% | `[██████████] 100%` |
| statement | 40 | 100% | `[██████████] 100%` |
| locations | 40 | 100% | `[██████████] 100%` |
| code_flow | 40 | 100% | `[██████████] 100%` |
| obligation_gap | 0 | 0% | `[░░░░░░░░░░] 0%` |
| code_gap | 0 | 0% | `[░░░░░░░░░░] 0%` |
| client_locations | 40 | 100% | `[██████████] 100%` |
| client_code_flow | 40 | 100% | `[██████████] 100%` |
| client_obligation_gap | 1 | 2% | `[░░░░░░░░░░] 2%` |
| client_code_gap | 0 | 0% | `[░░░░░░░░░░] 0%` |

## Findings
### client_obligation_gap
- **EIP7702-OBL-030**: geth checks isPrecompile on original address addr, not the delegation target. If EOA is delegated to precompile, the original addr is NOT a precompile, so resolveCode will be called and fetch code from precompile address (which is empty for precompiles). This matches spec behavior.


## Definitions

| Column | Description |
| :--- | :--- |
| **obligation_gap** | Discrepancies between the extracted obligation and the EIP text (Phase 1A/1B). |
| **code_gap** | Discrepancies between the obligation and the Reference Implementation intent (Phase 1B). |
| **client_obligation_gap** | Discrepancies between the Client Implementation and the EIP Obligation (Phase 2B). |
| **client_code_gap** | Discrepancies between the Client Implementation and the Reference Implementation (Phase 2B). |


<details>
<summary>Full CSV Output (Phase 2B)</summary>

```csv
id,category,enforcement_type,statement,locations,code_flow,obligation_gap,code_gap,client_locations,client_code_flow,client_obligation_gap,client_code_gap
EIP7702-OBL-001,tx validation,type-identifier,The TransactionType for a set code transaction MUST be SET_CODE_TX_TYPE (0x04).,"[transactions.py:L494, transactions.py:L514-L515]",fork.py:apply_body() -> fork.py:process_transaction() -> transactions.py:encode_transaction() [L493-494: SetCodeTransaction returns b'\x04' prefix]; transactions.py:decode_transaction() [L514-515: tx[0]==4 decodes to SetCodeTransaction],,,"[core/types/transaction.go:L52, core/types/tx_setcode.go:L186]",Transaction decoding -> transaction.go:decodeTyped() [L201-220: switch b[0] case SetCodeTxType=0x04 creates SetCodeTx]; tx_setcode.go:txType() [L186: returns SetCodeTxType],,
EIP7702-OBL-002,tx validation,struct-definition,"The TransactionPayload MUST be the RLP serialization of [chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, value, data, access_list, authorization_list, signature_y_parity, signature_r, signature_s].","[transactions.py:L382-L462, transactions.py:L838-L863]",fork.py:apply_body() -> fork.py:process_transaction() -> transactions.py:decode_transaction() -> ethereum_rlp.decode_to(SetCodeTransaction) [L515]; SetCodeTransaction dataclass [L382-462] defines RLP fields; transactions.py:signing_hash_7702() [L838-863] encodes fields in order,,,"[core/types/tx_setcode.go:L51-L67, core/types/tx_setcode.go:L228-L243]","core/types/tx_setcode.go:SetCodeTx struct [L51-67: defines ChainID, Nonce, GasTipCap, GasFeeCap, Gas, To, Value, Data, AccessList, AuthList, V, R, S]; sigHash() [L228-243: computes keccak256(SetCodeTxType || rlp(fields))]",,
EIP7702-OBL-003,tx validation,explicit-check,A set code transaction MUST have a non-null destination.,"[fork.py:L506-L508, transactions.py:L420]",fork.py:apply_body() -> fork.py:process_transaction() -> fork.py:check_transaction() [L506-508: raises TransactionTypeContractCreationError if tx.to is not Address]; SetCodeTransaction.to typed as Address [L420],,,"[core/types/tx_setcode.go:L57, core/types/tx_setcode.go:L196, core/state_transition.go:L401-L407]","core/types/tx_setcode.go:SetCodeTx.To [L57: To common.Address - not a pointer, non-null by type]; to() [L196: returns &tmp]; core/state_transition.go:preCheck() [L401-407: if SetCodeAuthorizations != nil && msg.To == nil returns ErrSetCodeTxCreate]",,
EIP7702-OBL-004,tx validation,crypto-verification,The transaction signature MUST be a secp256k1 signature over keccak256(SET_CODE_TX_TYPE || TransactionPayload).,"[transactions.py:L696-L701, transactions.py:L838-L863]",fork.py:apply_body() -> fork.py:process_transaction() -> fork.py:check_transaction() -> transactions.py:recover_sender() [L696-701: for SetCodeTransaction calls secp256k1_recover with signing_hash_7702]; signing_hash_7702() [L838-863: computes keccak256(b'\x04' || rlp(...))],,,"[core/types/tx_setcode.go:L228-L243, core/types/transaction_signing.go]",Transaction validation -> types.Sender() -> signer.Sender() -> ecrecover; tx_setcode.go:sigHash() [L228-243: computes keccak256(0x04 || rlp(...))],,
EIP7702-OBL-005,tx validation,explicit-check,The transaction is invalid if the length of authorization_list is zero.,"[fork.py:L510-L512, exceptions.py:L106-L109]",fork.py:apply_body() -> fork.py:process_transaction() -> fork.py:check_transaction() [L510-512: if not any(tx.authorizations) raises EmptyAuthorizationListError]; exceptions.py:EmptyAuthorizationListError [L106-109],,,"[core/state_transition.go:L405-L407, core/error.go:L130, core/txpool/validation.go:L149-L153]",core/state_transition.go:preCheck() [L405-407: if len(SetCodeAuthorizations) == 0 returns ErrEmptyAuthList]; core/error.go [L130: ErrEmptyAuthList definition]; txpool/validation.go [L149-153: SetCodeTxType requires non-empty auth list],,
EIP7702-OBL-006,tx validation,type-constraint,The authorization tuple chain_id field MUST be less than 2**256.,[fork_types.py:L73],RLP decode -> fork_types.py:Authorization [L73: chain_id: U256] - U256 type constraint enforces < 2**256,,,[core/types/tx_setcode.go:L73],RLP decode -> SetCodeAuthorization struct [L73: ChainID uint256.Int] - uint256.Int enforces < 2^256,,
EIP7702-OBL-007,tx validation,type-constraint,The authorization tuple nonce field MUST be less than 2**64.,[fork_types.py:L75],RLP decode -> fork_types.py:Authorization [L75: nonce: U64] - U64 type constraint enforces < 2**64,,,[core/types/tx_setcode.go:L75],RLP decode -> SetCodeAuthorization struct [L75: Nonce uint64] - uint64 type enforces < 2^64,,
EIP7702-OBL-008,tx validation,type-constraint,The authorization tuple address field MUST be exactly 20 bytes.,[fork_types.py:L74],RLP decode -> fork_types.py:Authorization [L74: address: Address] - Address = Bytes20 enforces exactly 20 bytes,,,[core/types/tx_setcode.go:L74],"RLP decode -> SetCodeAuthorization struct [L74: Address common.Address] - common.Address is [20]byte, exactly 20 bytes",,
EIP7702-OBL-009,tx validation,type-constraint,The authorization tuple y_parity field MUST be less than 2**8.,[fork_types.py:L76],RLP decode -> fork_types.py:Authorization [L76: y_parity: U8] - U8 type constraint enforces < 2**8,,,[core/types/tx_setcode.go:L76],RLP decode -> SetCodeAuthorization struct [L76: V uint8] - uint8 type enforces < 2^8,,
EIP7702-OBL-010,tx validation,type-constraint,The authorization tuple r field MUST be less than 2**256.,[fork_types.py:L77],RLP decode -> fork_types.py:Authorization [L77: r: U256] - U256 type constraint enforces < 2**256,,,[core/types/tx_setcode.go:L77],RLP decode -> SetCodeAuthorization struct [L77: R uint256.Int] - uint256.Int enforces < 2^256,,
EIP7702-OBL-011,tx validation,type-constraint,The authorization tuple s field MUST be less than 2**256.,[fork_types.py:L78],RLP decode -> fork_types.py:Authorization [L78: s: U256] - U256 type constraint enforces < 2**256,,,[core/types/tx_setcode.go:L78],RLP decode -> SetCodeAuthorization struct [L78: S uint256.Int] - uint256.Int enforces < 2^256,,
EIP7702-OBL-012,execution semantics,control-flow-ordering,"The authorization list MUST be processed before the execution portion of the transaction begins, but after the sender's nonce is incremented.","[vm/interpreter.py:L126-L127, fork.py:L879]",fork.py:process_transaction() -> fork.py:prepare_message() -> vm/interpreter.py:process_message_call() [L126-127: calls set_delegation(message) before process_message()]; fork.py:process_transaction() [L879: increment_nonce called before prepare_message],,,"[core/state_transition.go:L503, core/state_transition.go:L506-L511]","core/state_transition.go:execute() [L503: SetNonce(msg.From, nonce+1) increments sender nonce]; [L506-511: for loop processes msg.SetCodeAuthorizations via applyAuthorization() before evm.Call()]",,
EIP7702-OBL-013,execution semantics,explicit-check,"For each authorization tuple, the chain ID MUST be verified to be 0 or the ID of the current chain.",[vm/eoa_delegation.py:L172-L173],"vm/interpreter.py:process_message_call() -> vm/eoa_delegation.py:set_delegation() [L172-173: if auth.chain_id not in (message.block_env.chain_id, U256(0)): continue]",,,"[core/state_transition.go:L579-L581, core/error.go:L140]",core/state_transition.go:validateAuthorization() [L579-581: if !auth.ChainID.IsZero() && auth.ChainID.CmpBig(chainConfig.ChainID) != 0 returns ErrAuthorizationWrongChainID],,
EIP7702-OBL-014,execution semantics,explicit-check,"For each authorization tuple, the nonce MUST be verified to be less than 2**64 - 1.",[vm/eoa_delegation.py:L175-L176],vm/interpreter.py:process_message_call() -> vm/eoa_delegation.py:set_delegation() [L175-176: if auth.nonce >= U64.MAX_VALUE: continue],,,"[core/state_transition.go:L583-L585, core/error.go:L141]",core/state_transition.go:validateAuthorization() [L583-585: if auth.Nonce+1 < auth.Nonce returns ErrAuthorizationNonceOverflow] - checks nonce < 2^64-1,,
EIP7702-OBL-015,execution semantics,crypto-verification,"The authority address MUST be recovered using ecrecover(msg, y_parity, r, s) where msg = keccak(MAGIC || rlp([chain_id, address, nonce])).",[vm/eoa_delegation.py:L102-L114],"vm/interpreter.py:process_message_call() -> vm/eoa_delegation.py:set_delegation() -> vm/eoa_delegation.py:recover_authority() [L102-114: signing_hash = keccak256(SET_CODE_TX_MAGIC + rlp.encode((chain_id, address, nonce))); secp256k1_recover(r, s, y_parity, signing_hash)]",,,"[core/types/tx_setcode.go:L109-L115, core/types/tx_setcode.go:L118-L139]","tx_setcode.go:Authority() [L118-139: computes SigHash() then crypto.Ecrecover]; SigHash() [L109-115: returns prefixedRlpHash(0x05, [ChainID, Address, Nonce])]",,
EIP7702-OBL-016,execution semantics,explicit-check,The authorization tuple s value MUST be less than or equal to secp256k1n/2 as specified in EIP-2.,[vm/eoa_delegation.py:L99-L100],vm/interpreter.py:process_message_call() -> vm/eoa_delegation.py:set_delegation() -> vm/eoa_delegation.py:recover_authority() [L99-100: if s > SECP256K1N // U256(2): raise InvalidSignatureError],,,"[core/types/tx_setcode.go:L120, crypto/crypto.go]","tx_setcode.go:Authority() [L120: calls crypto.ValidateSignatureValues(a.V, R, S, true)]; crypto/crypto.go: if homestead && s.Cmp(secp256k1halfN) > 0 return false",,
EIP7702-OBL-017,execution semantics,state-mutation,The authority address MUST be added to accessed_addresses as defined in EIP-2929.,[vm/eoa_delegation.py:L183],vm/interpreter.py:process_message_call() -> vm/eoa_delegation.py:set_delegation() [L183: message.accessed_addresses.add(authority)],,,[core/state_transition.go:L596],core/state_transition.go:validateAuthorization() [L596: st.state.AddAddressToAccessList(authority)] adds authority to accessed_addresses,,
EIP7702-OBL-018,execution semantics,explicit-check,The code of authority MUST be empty or already delegated for the authorization to be valid.,[vm/eoa_delegation.py:L188-L189],vm/interpreter.py:process_message_call() -> vm/eoa_delegation.py:set_delegation() [L188-189: if authority_code and not is_valid_delegation(authority_code): continue],,,"[core/state_transition.go:L597-L600, core/types/tx_setcode.go:L37-L42]","core/state_transition.go:validateAuthorization() [L597-600: if _, ok := types.ParseDelegation(code); len(code) != 0 && !ok returns ErrAuthorizationDestinationHasCode]; tx_setcode.go:ParseDelegation() [L37-42: checks 0xef0100 prefix and len==23]",,
EIP7702-OBL-019,execution semantics,explicit-check,The nonce of authority MUST be equal to the nonce in the authorization tuple.,[vm/eoa_delegation.py:L191-L193],vm/interpreter.py:process_message_call() -> vm/eoa_delegation.py:set_delegation() [L191-193: if authority_nonce != auth.nonce: continue],,,"[core/state_transition.go:L601-L603, core/error.go:L144]",core/state_transition.go:validateAuthorization() [L601-603: if have := st.state.GetNonce(authority); have != auth.Nonce returns ErrAuthorizationNonceMismatch],,
EIP7702-OBL-020,fees,state-mutation,PER_EMPTY_ACCOUNT_COST - PER_AUTH_BASE_COST gas MUST be added to the global refund counter if authority is not empty.,[vm/eoa_delegation.py:L195-L196],"vm/interpreter.py:process_message_call() -> vm/eoa_delegation.py:set_delegation() [L195-196: if account_exists(state, authority): refund_counter += U256(PER_EMPTY_ACCOUNT_COST - PER_AUTH_BASE_COST)]",,,"[core/state_transition.go:L616-L618, params/protocol_params.go:L37, params/protocol_params.go:L101]","core/state_transition.go:applyAuthorization() [L616-618: if st.state.Exist(authority) adds refund CallNewAccountGas - TxAuthTupleGas]; params [L37: CallNewAccountGas=25000, L101: TxAuthTupleGas=12500]",,
EIP7702-OBL-021,execution semantics,state-mutation,The code of authority MUST be set to 0xef0100 || address (the delegation indicator).,[vm/eoa_delegation.py:L201-L202],"vm/interpreter.py:process_message_call() -> vm/eoa_delegation.py:set_delegation() [L201-202: code_to_set = EOA_DELEGATION_MARKER + auth.address; set_code(state, authority, code_to_set)]",,,"[core/state_transition.go:L628-L629, core/types/tx_setcode.go:L45-L47, core/types/tx_setcode.go:L34]","core/state_transition.go:applyAuthorization() [L628-629: st.state.SetCode(authority, types.AddressToDelegation(auth.Address))]; tx_setcode.go:AddressToDelegation() [L45-47: returns DelegationPrefix || address]; DelegationPrefix [L34: []byte{0xef, 0x01, 0x00}]",,
EIP7702-OBL-022,execution semantics,explicit-check,"If address is 0x0000000000000000000000000000000000000000, the delegation indicator MUST NOT be written; instead the account's code MUST be cleared by resetting the code hash to the empty code hash.",[vm/eoa_delegation.py:L198-L202],vm/interpreter.py:process_message_call() -> vm/eoa_delegation.py:set_delegation() [L198-202: if auth.address == NULL_ADDRESS: code_to_set = b'' else: code_to_set = EOA_DELEGATION_MARKER + auth.address],,,[core/state_transition.go:L622-L626],"core/state_transition.go:applyAuthorization() [L622-626: if auth.Address == (common.Address{}) then st.state.SetCode(authority, nil) clears code]",,
EIP7702-OBL-023,execution semantics,state-mutation,The nonce of authority MUST be increased by one after setting the delegation.,[vm/eoa_delegation.py:L204],"vm/interpreter.py:process_message_call() -> vm/eoa_delegation.py:set_delegation() [L204: increment_nonce(state, authority)]",,,[core/state_transition.go:L621],"core/state_transition.go:applyAuthorization() [L621: st.state.SetNonce(authority, auth.Nonce+1)] increments authority nonce after setting delegation",,
EIP7702-OBL-024,execution semantics,control-flow,"If any authorization processing step fails, processing of that tuple MUST stop immediately and continue to the next tuple.",[vm/eoa_delegation.py:L172-L193],vm/interpreter.py:process_message_call() -> vm/eoa_delegation.py:set_delegation() [L172-193: each check uses 'continue' to skip to next tuple on failure],,,"[core/state_transition.go:L609-L612, core/state_transition.go:L506-L511]",core/state_transition.go:applyAuthorization() [L609-612: if err := validateAuthorization() returns err without aborting tx]; execute() [L506-511: for loop ignores errors via st.applyAuthorization(&auth)],,
EIP7702-OBL-025,execution semantics,implicit-ordering,"When multiple tuples from the same authority are present, the code MUST be set using the address in the last valid occurrence.",[vm/eoa_delegation.py:L171-L204],vm/interpreter.py:process_message_call() -> vm/eoa_delegation.py:set_delegation() [L171-204: for loop processes authorizations in order; each valid authorization overwrites previous set_code for same authority],,,[core/state_transition.go:L506-L511],"core/state_transition.go:execute() [L506-511: for loop processes authorizations in order; each applyAuthorization() calls SetCode, so later valid authorizations overwrite earlier ones for same authority]",,
EIP7702-OBL-026,execution semantics,control-flow-ordering,"If transaction execution results in failure (exceptional condition or code reverting), the processed delegation indicators MUST NOT be rolled back.","[vm/interpreter.py:L126-L127, vm/interpreter.py:L138-L144]","vm/interpreter.py:process_message_call() [L126-127: set_delegation called before process_message; L138-144: error only affects logs/accounts_to_delete, not delegation set earlier]; delegations are set outside the transaction snapshot",,,"[core/state_transition.go:L506-L523, core/vm/evm.go:L257, core/vm/evm.go:L304-L306]",core/state_transition.go:execute() [L506-511: applyAuthorization() modifies state before evm.Call()]; evm.go:Call() [L257: snapshot taken after auth processing; L304-306: revert to snapshot on error does NOT affect delegations set earlier],,
EIP7702-OBL-027,execution semantics,delegation-resolution,"All code executing operations (CALL, CALLCODE, DELEGATECALL, STATICCALL, and transactions targeting a delegated address) MUST follow the delegation indicator to load and execute the code at the pointed address.","[vm/instructions/system.py:L382-L389, vm/instructions/system.py:L471-L477, vm/instructions/system.py:L612-L618, vm/instructions/system.py:L682-L688, vm/interpreter.py:L129-L134]","vm/instructions/system.py:call() [L382-389: access_delegation(evm, code_address)]; vm/instructions/system.py:callcode() [L471-477: access_delegation(...)]; vm/instructions/system.py:delegatecall() [L612-618: access_delegation(...)]; vm/instructions/system.py:staticcall() [L682-688: access_delegation(...)]; vm/interpreter.py:process_message_call() [L129-134: delegated_address = get_delegated_code_address(message.code)]",,,"[core/vm/evm.go:L628-L638, core/vm/evm.go:L289, core/vm/evm.go:L355, core/vm/evm.go:L399, core/vm/evm.go:L450]","core/vm/evm.go:resolveCode() [L628-638: if ParseDelegation(code) ok, returns StateDB.GetCode(target)]; Call() [L289: code := evm.resolveCode(addr)]; CallCode() [L355: resolveCode(addr)]; DelegateCall() [L399: resolveCode(addr)]; StaticCall() [L450: resolveCode(addr)]",,
EIP7702-OBL-028,execution semantics,implicit-context,CODESIZE and CODECOPY instructions MUST operate on the executing code (the delegated code) rather than the delegation indicator.,"[vm/instructions/environment.py:L249-L269, vm/instructions/environment.py:L272-L304]","vm/instructions/environment.py:codesize() [L249-269: push(evm.stack, U256(len(evm.code))) where evm.code is the executing code]; vm/instructions/environment.py:codecopy() [L272-304: buffer_read(evm.code, ...) reads from executing code]",,,[core/vm/evm.go:L294-L297],"evm.go:Call() [L294-297: contract.SetCallCode(resolveCodeHash(addr), code) where code is already resolved delegation target]; opcodes CODESIZE/CODECOPY operate on contract.Code which is the delegated code",,
EIP7702-OBL-029,execution semantics,explicit-check,"When a precompile address is the target of a delegation, the retrieved code MUST be considered empty.","[vm/interpreter.py:L296-L298, vm/eoa_delegation.py:access_delegation]",vm/interpreter.py:process_message() [L296-298: if code_address in PRE_COMPILED_CONTRACTS and message.disable_precompiles: return evm (empty execution)]; vm/eoa_delegation.py:access_delegation() [L138-139: returns code from delegated address],,,"[core/vm/evm.go:L285-L286, core/vm/evm.go:L258]","evm.go:Call() [L258: p, isPrecompile := evm.precompile(addr)]; if address is precompile, handled separately [L285-286: RunPrecompiledContract]; delegation resolution only for non-precompiles so precompile-delegated code is empty",,
EIP7702-OBL-030,execution semantics,explicit-check,"CALL, CALLCODE, STATICCALL, DELEGATECALL instructions targeting an account delegated to a precompile MUST execute empty code (succeed with no execution when given enough gas).",[vm/interpreter.py:L296-L302],vm/interpreter.py:process_message() [L296-302: if code_address in PRE_COMPILED_CONTRACTS and disable_precompiles: return evm immediately with no execution],,,"[core/vm/evm.go:L285-L286, core/vm/evm.go:L289-L299]","evm.go:Call() [L285-286: if isPrecompile, runs precompile]; [L289-299: else resolveCode - if delegating to precompile, resolveCode returns precompile code but Call checks isPrecompile first on original addr, not delegated]","geth checks isPrecompile on original address addr, not the delegation target. If EOA is delegated to precompile, the original addr is NOT a precompile, so resolveCode will be called and fetch code from precompile address (which is empty for precompiles). This matches spec behavior.",
EIP7702-OBL-031,execution semantics,single-resolution,"If a delegation indicator points to another delegation, clients MUST retrieve only the first code and stop following the delegation chain.","[vm/interpreter.py:L129-L134, vm/eoa_delegation.py:L138-L139]","vm/interpreter.py:process_message_call() [L129-134: get_delegated_code_address called once]; vm/eoa_delegation.py:access_delegation() [L138-139: only checks is_valid_delegation once, does not recurse]",,,[core/vm/evm.go:L633-L636],"evm.go:resolveCode() [L633-636: if target, ok := ParseDelegation(code); ok returns StateDB.GetCode(target)] - only ONE level of resolution, does not recurse",,
EIP7702-OBL-032,fees,gas-calculation,The intrinsic cost MUST include: 21000 + 16 * non-zero calldata bytes + 4 * zero calldata bytes + 1900 * access list storage key count + 2400 * access list address count.,"[transactions.py:L564-L639, transactions.py:L26-L61]","fork.py:process_transaction() -> transactions.py:calculate_intrinsic_cost() [L564-639: TX_BASE_COST(21000) + data_cost + access_list_cost]; transactions.py constants [L26-61: TX_BASE_COST, STANDARD_CALLDATA_TOKEN_COST(4), TX_ACCESS_LIST_ADDRESS_COST(2400), TX_ACCESS_LIST_STORAGE_KEY_COST(1900)]",,,"[core/state_transition.go:L71-L117, params/protocol_params.go:L38-L40, params/protocol_params.go:L99-L100]","core/state_transition.go:IntrinsicGas() [L71-117: TxGas(21000) + data cost + accessList cost]; params [L38: TxGas=21000, L40: TxDataZeroGas=4, L99: TxAccessListAddressGas=2400, L100: TxAccessListStorageKeyGas=1900]",,
EIP7702-OBL-033,fees,gas-calculation,The intrinsic cost MUST add PER_EMPTY_ACCOUNT_COST (25000) * authorization list length.,"[transactions.py:L626-L628, vm/eoa_delegation.py:L25]",fork.py:process_transaction() -> transactions.py:calculate_intrinsic_cost() [L626-628: auth_cost += Uint(PER_EMPTY_ACCOUNT_COST * len(tx.authorizations))]; vm/eoa_delegation.py [L25: PER_EMPTY_ACCOUNT_COST = 25000],,,"[core/state_transition.go:L113-L115, params/protocol_params.go:L37]",core/state_transition.go:IntrinsicGas() [L113-115: if authList != nil adds len(authList) * CallNewAccountGas]; params [L37: CallNewAccountGas=25000 is PER_EMPTY_ACCOUNT_COST],,
EIP7702-OBL-034,fees,gas-calculation,"The transaction sender MUST pay for all authorization tuples, regardless of validity or duplication.",[transactions.py:L626-L628],transactions.py:calculate_intrinsic_cost() [L626-628: charges auth_cost based on len(tx.authorizations) regardless of validity]; validation happens later in set_delegation(),,,[core/state_transition.go:L113-L115],core/state_transition.go:IntrinsicGas() [L113-115: charges len(authList) * CallNewAccountGas] - uses len(authList) regardless of validity; validation happens later in applyAuthorization(),,
EIP7702-OBL-035,fees,gas-charging,"If a code executing instruction accesses a cold account during delegation resolution, an additional COLD_ACCOUNT_READ_COST (2600 gas) MUST be charged and the account MUST be added to accessed_addresses.","[vm/eoa_delegation.py:L144-L146, vm/gas.py:L65]",vm/eoa_delegation.py:access_delegation() [L144-146: if address not in evm.accessed_addresses: access_gas_cost = GAS_COLD_ACCOUNT_ACCESS; evm.accessed_addresses.add(address)]; vm/gas.py [L65: GAS_COLD_ACCOUNT_ACCESS = 2600],,,"[core/vm/operations_acl.go:L274-L287, params/protocol_params.go:L68]",core/vm/operations_acl.go:makeCallVariantGasCallEIP7702() [L274-287: if !AddressInAccessList(target) charges ColdAccountAccessCostEIP2929 and adds to access list]; params [L68: ColdAccountAccessCostEIP2929=2600],,
EIP7702-OBL-036,fees,gas-charging,"If a code executing instruction accesses a warm account during delegation resolution, a WARM_STORAGE_READ_COST (100 gas) MUST be charged.","[vm/eoa_delegation.py:L142-L143, vm/gas.py:L66]",vm/eoa_delegation.py:access_delegation() [L142-143: if address in evm.accessed_addresses: access_gas_cost = GAS_WARM_ACCESS]; vm/gas.py [L66: GAS_WARM_ACCESS = 100],,,"[core/vm/operations_acl.go:L277-L279, params/protocol_params.go:L70]",core/vm/operations_acl.go:makeCallVariantGasCallEIP7702() [L277-279: if AddressInAccessList(target) charges WarmStorageReadCostEIP2929]; params [L70: WarmStorageReadCostEIP2929=100],,
EIP7702-OBL-037,tx validation,explicit-check,EOAs whose code is a valid delegation indicator (0xef0100 || address) MUST be allowed to originate transactions.,"[fork.py:L521-L522, vm/eoa_delegation.py:is_valid_delegation]",fork.py:check_transaction() [L521-522: if sender_account.code and not is_valid_delegation(sender_account.code): raise InvalidSenderError]; vm/eoa_delegation.py:is_valid_delegation() [L30-51: checks for 0xef0100 prefix and length 23],,,"[core/state_transition.go:L334-L338, core/types/tx_setcode.go:L37-L42]","core/state_transition.go:preCheck() [L334-338: if _, delegated := types.ParseDelegation(code); len(code) > 0 && !delegated returns ErrSenderNoEOA]; ParseDelegation() [L37-42: valid if len==23 && HasPrefix(DelegationPrefix)]",,
EIP7702-OBL-038,tx validation,explicit-check,Accounts with any code value other than a valid delegation indicator MUST NOT be allowed to originate transactions.,[fork.py:L521-L522],fork.py:check_transaction() [L521-522: if sender_account.code and not is_valid_delegation(sender_account.code): raise InvalidSenderError('not EOA')],,,"[core/state_transition.go:L334-L338, core/error.go:L110]",core/state_transition.go:preCheck() [L334-338: if len(code) > 0 && !delegated returns ErrSenderNoEOA]; core/error.go [L110: ErrSenderNoEOA = sender not an eoa],,
EIP7702-OBL-039,execution semantics,state-mutation,"If a transaction's destination has a delegation indicator, the target of the delegation MUST be added to accessed_addresses.",[vm/interpreter.py:L129-L134],vm/interpreter.py:process_message_call() [L129-134: if delegated_address is not None: message.accessed_addresses.add(delegated_address)],,,[core/state_transition.go:L518-L520],"core/state_transition.go:execute() [L518-520: if addr, ok := types.ParseDelegation(GetCode(*msg.To)); ok then AddAddressToAccessList(addr)] adds delegation target to access list",,
EIP7702-OBL-040,tx validation,encoding,"The ReceiptPayload for a set code transaction MUST be rlp([status, cumulative_transaction_gas_used, logs_bloom, logs]).","[blocks.py:L363-L384, blocks.py:L333-L359]","fork.py:process_transaction() -> fork.py:make_receipt() -> blocks.py:encode_receipt() [L363-384: SetCodeTransaction receipt is b'\x04' + rlp.encode(receipt)]; blocks.py:Receipt [L333-359: contains succeeded, cumulative_gas_used, bloom, logs]",,,"[core/types/receipt.go:L121-L141, core/types/receipt.go:L138-L141]","core/types/receipt.go:EncodeRLP() [L123-135: for typed tx writes type byte prefix then RLP data]; encodeTyped() [L138-141: w.WriteByte(r.Type) then rlp.Encode(receiptRLP)] - receiptRLP has [status, cumGasUsed, bloom, logs]",,

```
</details>