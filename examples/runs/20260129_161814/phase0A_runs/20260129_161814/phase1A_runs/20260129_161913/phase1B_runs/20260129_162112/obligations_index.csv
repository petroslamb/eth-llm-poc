id,category,enforcement_type,statement,locations,code_flow,obligation_gap,code_gap
EIP2930-OBL-001,tx validation,format constraint,EIP-2930 transactions MUST use TransactionType 1.,"[transactions.py:L224, transactions.py:L238-L240, exceptions.py:L10-L24]",apply_body() -> decode_transaction(tx) -> if tx[0] != 1 -> raises TransactionTypeError(tx[0]). Entry point: fork.py:apply_body():L475 calls decode_transaction() on each transaction. Enforcement: transactions.py:L238-L239 checks tx[0] != 1 and raises TransactionTypeError.,,
EIP2930-OBL-002,tx validation,format constraint,"The EIP-2718 TransactionPayload for type 1 transactions MUST be rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, signatureYParity, signatureR, signatureS]).","[transactions.py:L137-L204, transactions.py:L223-L224, transactions.py:L240]","decode_transaction(tx) -> rlp.decode_to(AccessListTransaction, tx[1:]). Entry point: fork.py:apply_body():L475 -> decode_transaction() -> transactions.py:L240 decodes to AccessListTransaction dataclass (L137-L204). RLP decode will fail if structure doesn't match. Enforcement: rlp.decode_to() raises RLPDecodingError if field count/types don't match AccessListTransaction schema.",,
EIP2930-OBL-003,tx validation,signature validation,"The signature elements (signatureYParity, signatureR, signatureS) MUST represent a secp256k1 signature over keccak256(0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList])).","[transactions.py:L358-L363, transactions.py:L418-L441, transactions.py:L336-L340]","check_transaction() -> recover_sender(chain_id, tx) -> validates r/s range (L336-L340) -> secp256k1_recover(r, s, y_parity, signing_hash_2930(tx)). Entry point: fork.py:check_transaction():L388 -> recover_sender() -> transactions.py:L358-L363 (for AccessListTransaction). signing_hash_2930():L418-L441 computes keccak256(0x01 || rlp([...])). Enforcement: InvalidSignatureError raised if r/s invalid or signature recovery fails.",,
EIP2930-OBL-004,tx validation,format constraint,"The EIP-2718 ReceiptPayload for type 1 transactions MUST be rlp([status, cumulativeGasUsed, logsBloom, logs]).","[blocks.py:L238-L268, blocks.py:L270-L281]","make_receipt(tx, ...) -> encode_receipt(tx, receipt). Entry point: fork.py:process_transaction():L715-L716 -> make_receipt() -> fork.py:L439 -> encode_receipt(). Enforcement: blocks.py:L270-L281 encode_receipt() prefixes with 0x01 and RLP encodes the Receipt dataclass (L238-L268). Receipt structure matches spec: succeeded(status), cumulative_gas_used, bloom, logs.",,
EIP2930-OBL-005,tx validation,format constraint,"For the transaction to be valid, accessList MUST be of type [[{20 bytes}, [{32 bytes}...]]...] (a list of [address, storage_keys] pairs where address is 20 bytes and each storage key is 32 bytes).","[transactions.py:L116-L133, transactions.py:L185]","decode_transaction() -> rlp.decode_to(AccessListTransaction, ...). AccessListTransaction.access_list is Tuple[Access, ...] (L185) where Access contains 'account: Address' (20 bytes) and 'slots: Tuple[Bytes32, ...]' (32 bytes each). Enforcement: RLP decoding to Access dataclass enforces Address=20 bytes via type, Bytes32=32 bytes via type. Implicit via ethereum_types type constraints.",,RLP decode relies on ethereum_types type validation; explicit length checks not visible in code. Access class at L116-L133 defines structure but actual byte-length enforcement is delegated to ethereum_types/RLP library.
EIP2930-OBL-006,tx validation,format constraint,Each item in the accessList MUST be a list of exactly 2 elements.,[transactions.py:L116-L133],"decode_transaction() -> rlp.decode_to(AccessListTransaction, ...) -> decodes access_list to Tuple[Access, ...]. Access dataclass (L116-L133) has exactly 2 fields: account and slots. Enforcement: RLP decode_to() enforces structure match with Access dataclass having 2 fields.",,Enforcement implicit via RLP decode to Access dataclass. No explicit 2-element check visible in code; relies on RLP library behavior.
EIP2930-OBL-007,tx validation,format constraint,Each address in the accessList MUST be exactly 20 bytes.,[transactions.py:L124],decode_transaction() -> rlp.decode_to() -> Access.account: Address. Address is defined as 20-byte type. Enforcement: transactions.py:L124 declares 'account: Address' where Address is Bytes20.,,Length enforcement via Address type definition (Bytes20). Not an explicit length check in transactions.py.
EIP2930-OBL-008,tx validation,format constraint,The storage keys element of each accessList item MUST be a list.,[transactions.py:L129],"decode_transaction() -> rlp.decode_to() -> Access.slots: Tuple[Bytes32, ...]. Enforcement: transactions.py:L129 declares 'slots: Tuple[Bytes32, ...]' - a tuple type.",,"Enforcement via type annotation Tuple[...]. No explicit isinstance(slots, list) check."
EIP2930-OBL-009,tx validation,format constraint,Each storage key in the accessList MUST be exactly 32 bytes.,[transactions.py:L129],"decode_transaction() -> rlp.decode_to() -> Access.slots: Tuple[Bytes32, ...]. Enforcement: transactions.py:L129 declares slots as Tuple[Bytes32, ...] where Bytes32 enforces 32-byte length.",,Length enforcement via Bytes32 type. Not an explicit length check.
EIP2930-OBL-010,fees,gas charging,ACCESS_LIST_ADDRESS_COST (2400 gas) MUST be charged for each address in the access list.,"[transactions.py:L47-L49, transactions.py:L312-L314]","validate_transaction() -> calculate_intrinsic_cost(tx). Entry point: fork.py:process_transaction():L638 -> validate_transaction() -> calculate_intrinsic_cost():L276-L319. Enforcement: transactions.py:L312-L314 adds TX_ACCESS_LIST_ADDRESS_COST (2400, defined L47-L49) for each access in tx.access_list.",,
EIP2930-OBL-011,fees,gas charging,ACCESS_LIST_STORAGE_KEY_COST (1900 gas) MUST be charged for each storage key in the access list.,"[transactions.py:L52-L55, transactions.py:L315-L317]","validate_transaction() -> calculate_intrinsic_cost(tx). Entry point: fork.py:process_transaction():L638 -> validate_transaction() -> calculate_intrinsic_cost():L276-L319. Enforcement: transactions.py:L315-L317 adds ulen(access.slots) * TX_ACCESS_LIST_STORAGE_KEY_COST (1900, defined L52-L55).",,
EIP2930-OBL-012,fees,gas charging,The access list gas charge MUST occur at the beginning of execution (at the same time as the intrinsic gas is charged according to EIP-2028 rules).,"[transactions.py:L276-L319, fork.py:L638, transactions.py:L268-L270]",Entry point: fork.py:process_transaction():L638 calls validate_transaction() BEFORE execution. validate_transaction():L268-L270 calls calculate_intrinsic_cost() which includes access_list_cost in total intrinsic_gas (L311-L317). Gas deducted from tx.gas at L648 (gas = tx.gas - intrinsic_gas) before message execution.,,
EIP2930-OBL-013,execution semantics,state initialization,Addresses from the access list MUST be immediately loaded into the accessed_addresses global set at the beginning of execution.,"[fork.py:L657-L661, utils/message.py:L49-L52, vm/__init__.py:L90, vm/interpreter.py:L242]",Entry point: fork.py:process_transaction():L657-L663 extracts access_list_addresses from tx.access_list. fork.py:L669 passes to TransactionEnvironment. prepare_message():L49-L52 adds tx_env.access_list_addresses to accessed_addresses. Message created with accessed_addresses (L87). vm/interpreter.py:L242 initializes Evm.accessed_addresses from message.accessed_addresses.,,
EIP2930-OBL-014,execution semantics,state initialization,Storage keys from the access list MUST be immediately loaded into the accessed_storage_keys global set at the beginning of execution (as address-key pairs).,"[fork.py:L657-L663, utils/message.py:L88, vm/__init__.py:L91, vm/interpreter.py:L243]","Entry point: fork.py:process_transaction():L657-L663 extracts (account, slot) pairs into access_list_storage_keys. fork.py:L670 passes to TransactionEnvironment. prepare_message():L88 sets accessed_storage_keys from tx_env. vm/interpreter.py:L243 initializes Evm.accessed_storage_keys from message.accessed_storage_keys.",,
EIP2930-OBL-015,fees,gas charging,Non-unique addresses and storage keys in the access list MUST be charged for multiple times.,[transactions.py:L311-L317],calculate_intrinsic_cost():L311-L317 iterates over tx.access_list without deduplication. For-loop at L313 processes 'for access in tx.access_list' meaning duplicate addresses are charged. ulen(access.slots) at L316 counts all slots including duplicates. Enforcement: No set() or deduplication applied before gas calculation.,,
EIP2930-OBL-016,fees,implicit exclusion,The access list MUST NOT be charged per-byte fees like transaction data.,"[transactions.py:L298-L305, transactions.py:L311-L317]",calculate_intrinsic_cost():L298-L305 calculates data_cost from tx.data bytes only. L311-L317 calculates access_list_cost separately using fixed per-address and per-key costs. Enforcement: access_list is NOT included in the byte-by-byte iteration at L300-L304; it has its own separate cost calculation.,,
EIP2930-OBL-017,block validation,fork activation,Type 1 transactions with access lists MUST only be valid as of FORK_BLOCK 12244000.,[],No explicit block number check visible in berlin/fork.py. The fork mechanism relies on the execution-specs directory structure where different forks have separate implementations.,"Spec requires fork activation at block 12244000, but code uses directory-based fork selection rather than block number checks within code.",No explicit FORK_BLOCK constant or block number validation found in berlin/ directory. Fork activation handled externally by client implementation selecting correct fork module.
EIP2930-OBL-018,tx validation,format constraint,The transaction MUST only be valid on networks with the specified chainID.,"[transactions.py:L148, fork.py:L388]","check_transaction() -> recover_sender(chain_id, tx). Entry point: fork.py:L388 passes block_env.chain_id to recover_sender(). For AccessListTransaction at L358-L363, signing_hash_2930(tx) at L362 includes tx.chain_id in hash. If tx.chain_id != block_env.chain_id, signature recovery will fail. Enforcement: Implicit via signature verification - wrong chain_id produces wrong hash, signature won't match, InvalidSignatureError raised.",,"Chain ID validation is implicit via signature verification. No explicit tx.chain_id == block_env.chain_id check found. If sender signed with different chain_id, secp256k1_recover will return wrong address, but no explicit error for chain mismatch."
EIP2930-OBL-019,tx validation,format constraint,YParity MUST be 0 for even or 1 for odd y-value of the secp256k1 signature.,"[transactions.py:L359-L360, transactions.py:L191]","recover_sender() for AccessListTransaction. Entry point: fork.py:check_transaction():L388 -> recover_sender() -> transactions.py:L358-L363. Enforcement: L359-L360 checks 'if tx.y_parity not in (U256(0), U256(1)): raise InvalidSignatureError(""bad y_parity"")'. y_parity field defined at L191.",,
