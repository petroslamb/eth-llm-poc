id,category,enforcement_type,statement,locations,code_flow,obligation_gap,code_gap,client_locations,client_code_flow,client_obligation_gap,client_code_gap
EIP2930-OBL-001,tx validation,format constraint,EIP-2930 transactions MUST use TransactionType 1.,"[transactions.py:L224, transactions.py:L238-L240, exceptions.py:L10-L24]",apply_body() -> decode_transaction(tx) -> if tx[0] != 1 -> raises TransactionTypeError(tx[0]). Entry point: fork.py:apply_body():L475 calls decode_transaction() on each transaction. Enforcement: transactions.py:L238-L239 checks tx[0] != 1 and raises TransactionTypeError.,,,"[core/types/transaction.go:L49, core/types/transaction.go:L206-L209, core/types/tx_access_list.go:L99]","Transaction.decodeTyped() checks tx type byte at b[0]. Entry: transaction.go:L201-L220. For type 0x01, creates AccessListTx (L207-L208). Enforcement: transaction.go:L215-L216 returns ErrTxTypeNotSupported for unknown types. Type constant AccessListTxType=0x01 at L49.",,
EIP2930-OBL-002,tx validation,format constraint,"The EIP-2718 TransactionPayload for type 1 transactions MUST be rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, signatureYParity, signatureR, signatureS]).","[transactions.py:L137-L204, transactions.py:L223-L224, transactions.py:L240]","decode_transaction(tx) -> rlp.decode_to(AccessListTransaction, tx[1:]). Entry point: fork.py:apply_body():L475 -> decode_transaction() -> transactions.py:L240 decodes to AccessListTransaction dataclass (L137-L204). RLP decode will fail if structure doesn't match. Enforcement: rlp.decode_to() raises RLPDecodingError if field count/types don't match AccessListTransaction schema.",,,"[core/types/tx_access_list.go:L48-L58, core/types/tx_access_list.go:L127-L129]","AccessListTx struct (L48-L58) defines RLP schema: ChainID, Nonce, GasPrice, Gas, To, Value, Data, AccessList, V, R, S. Entry: tx_access_list.go:decode():L127-L129 calls rlp.DecodeBytes(). Enforcement: RLP library validates field structure matches AccessListTx struct; returns decode error on mismatch.",,
EIP2930-OBL-003,tx validation,signature validation,"The signature elements (signatureYParity, signatureR, signatureS) MUST represent a secp256k1 signature over keccak256(0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList])).","[transactions.py:L358-L363, transactions.py:L418-L441, transactions.py:L336-L340]","check_transaction() -> recover_sender(chain_id, tx) -> validates r/s range (L336-L340) -> secp256k1_recover(r, s, y_parity, signing_hash_2930(tx)). Entry point: fork.py:check_transaction():L388 -> recover_sender() -> transactions.py:L358-L363 (for AccessListTransaction). signing_hash_2930():L418-L441 computes keccak256(0x01 || rlp([...])). Enforcement: InvalidSignatureError raised if r/s invalid or signature recovery fails.",,,"[core/types/tx_access_list.go:L131-L144, core/types/transaction_signing.go:L254-L270, crypto/crypto.go:L240-L251]","sigHash() at tx_access_list.go:L131-L144 computes keccak256(0x01 || rlp([chainID, nonce, gasPrice, gas, to, value, data, accessList])). modernSigner.Sender() at transaction_signing.go:L254-L270 recovers address using V+27, R, S via recoverPlain(). Enforcement: crypto.ValidateSignatureValues():L240-L251 validates v in {0,1}, r/s in [1,N). recoverPlain returns ErrInvalidSig on failure.",,
EIP2930-OBL-004,tx validation,format constraint,"The EIP-2718 ReceiptPayload for type 1 transactions MUST be rlp([status, cumulativeGasUsed, logsBloom, logs]).","[blocks.py:L238-L268, blocks.py:L270-L281]","make_receipt(tx, ...) -> encode_receipt(tx, receipt). Entry point: fork.py:process_transaction():L715-L716 -> make_receipt() -> fork.py:L439 -> encode_receipt(). Enforcement: blocks.py:L270-L281 encode_receipt() prefixes with 0x01 and RLP encodes the Receipt dataclass (L238-L268). Receipt structure matches spec: succeeded(status), cumulative_gas_used, bloom, logs.",,,"[core/types/receipt.go:L138-L141, core/types/receipt.go:L361-L378]","Receipt.encodeTyped():L138-L141 writes type byte then RLP(receiptRLP). receiptRLP struct:L91-L96 = [PostStateOrStatus, CumulativeGasUsed, Bloom, Logs]. Entry: Receipts.EncodeIndex():L361-L378 for tx type AccessListTxType writes 0x01 prefix. Enforcement: Type byte prefix matches tx type; RLP structure enforced by receiptRLP struct.",,
EIP2930-OBL-005,tx validation,format constraint,"For the transaction to be valid, accessList MUST be of type [[{20 bytes}, [{32 bytes}...]]...] (a list of [address, storage_keys] pairs where address is 20 bytes and each storage key is 32 bytes).","[transactions.py:L116-L133, transactions.py:L185]","decode_transaction() -> rlp.decode_to(AccessListTransaction, ...). AccessListTransaction.access_list is Tuple[Access, ...] (L185) where Access contains 'account: Address' (20 bytes) and 'slots: Tuple[Bytes32, ...]' (32 bytes each). Enforcement: RLP decoding to Access dataclass enforces Address=20 bytes via type, Bytes32=32 bytes via type. Implicit via ethereum_types type constraints.",,RLP decode relies on ethereum_types type validation; explicit length checks not visible in code. Access class at L116-L133 defines structure but actual byte-length enforcement is delegated to ethereum_types/RLP library.,"[core/types/tx_access_list.go:L29-L36, common/types.go:L198, common/types.go:L60]","AccessList=[]AccessTuple (L30). AccessTuple:L33-L36 has Address (common.Address=20 bytes) and StorageKeys ([]common.Hash=32 bytes each). Entry: tx_access_list.go:decode() via RLP. Enforcement: common.Address fixed at 20 bytes (types.go:L198), common.Hash fixed at 32 bytes (types.go:L60). RLP decode enforces size.",,
EIP2930-OBL-006,tx validation,format constraint,Each item in the accessList MUST be a list of exactly 2 elements.,[transactions.py:L116-L133],"decode_transaction() -> rlp.decode_to(AccessListTransaction, ...) -> decodes access_list to Tuple[Access, ...]. Access dataclass (L116-L133) has exactly 2 fields: account and slots. Enforcement: RLP decode_to() enforces structure match with Access dataclass having 2 fields.",,Enforcement implicit via RLP decode to Access dataclass. No explicit 2-element check visible in code; relies on RLP library behavior.,[core/types/tx_access_list.go:L33-L36],AccessTuple struct:L33-L36 has exactly 2 fields: Address and StorageKeys. Entry: RLP decode of AccessList via tx_access_list.go:decode(). Enforcement: RLP library decodes to struct with 2 fields; extra/missing fields cause decode error.,,
EIP2930-OBL-007,tx validation,format constraint,Each address in the accessList MUST be exactly 20 bytes.,[transactions.py:L124],decode_transaction() -> rlp.decode_to() -> Access.account: Address. Address is defined as 20-byte type. Enforcement: transactions.py:L124 declares 'account: Address' where Address is Bytes20.,,Length enforcement via Address type definition (Bytes20). Not an explicit length check in transactions.py.,"[core/types/tx_access_list.go:L34, common/types.go:L198]",AccessTuple.Address:L34 is common.Address type. common.Address defined as [AddressLength]byte where AddressLength=20 (types.go:L198). Entry: RLP decode. Enforcement: RLP library enforces exact 20-byte size for Address type.,,
EIP2930-OBL-008,tx validation,format constraint,The storage keys element of each accessList item MUST be a list.,[transactions.py:L129],"decode_transaction() -> rlp.decode_to() -> Access.slots: Tuple[Bytes32, ...]. Enforcement: transactions.py:L129 declares 'slots: Tuple[Bytes32, ...]' - a tuple type.",,"Enforcement via type annotation Tuple[...]. No explicit isinstance(slots, list) check.",[core/types/tx_access_list.go:L35],"AccessTuple.StorageKeys:L35 is []common.Hash, a slice type. Entry: RLP decode. Enforcement: RLP library decodes as list of Hash items.",,
EIP2930-OBL-009,tx validation,format constraint,Each storage key in the accessList MUST be exactly 32 bytes.,[transactions.py:L129],"decode_transaction() -> rlp.decode_to() -> Access.slots: Tuple[Bytes32, ...]. Enforcement: transactions.py:L129 declares slots as Tuple[Bytes32, ...] where Bytes32 enforces 32-byte length.",,Length enforcement via Bytes32 type. Not an explicit length check.,"[core/types/tx_access_list.go:L35, common/types.go:L60]","StorageKeys is []common.Hash where Hash=[HashLength]byte, HashLength=32 (types.go:L60). Entry: RLP decode. Enforcement: RLP library enforces exact 32-byte size for each Hash.",,
EIP2930-OBL-010,fees,gas charging,ACCESS_LIST_ADDRESS_COST (2400 gas) MUST be charged for each address in the access list.,"[transactions.py:L47-L49, transactions.py:L312-L314]","validate_transaction() -> calculate_intrinsic_cost(tx). Entry point: fork.py:process_transaction():L638 -> validate_transaction() -> calculate_intrinsic_cost():L276-L319. Enforcement: transactions.py:L312-L314 adds TX_ACCESS_LIST_ADDRESS_COST (2400, defined L47-L49) for each access in tx.access_list.",,,"[core/state_transition.go:L109-L111, params/protocol_params.go:L99]","IntrinsicGas():L71-L117 calculates gas. L109-L111: gas += len(accessList) * TxAccessListAddressGas (2400, protocol_params.go:L99). Entry: state_transition.go:execute():L446 calls IntrinsicGas(). Enforcement: Access list address cost included in intrinsic gas; tx rejected if gas < intrinsic.",,
EIP2930-OBL-011,fees,gas charging,ACCESS_LIST_STORAGE_KEY_COST (1900 gas) MUST be charged for each storage key in the access list.,"[transactions.py:L52-L55, transactions.py:L315-L317]","validate_transaction() -> calculate_intrinsic_cost(tx). Entry point: fork.py:process_transaction():L638 -> validate_transaction() -> calculate_intrinsic_cost():L276-L319. Enforcement: transactions.py:L315-L317 adds ulen(access.slots) * TX_ACCESS_LIST_STORAGE_KEY_COST (1900, defined L52-L55).",,,"[core/state_transition.go:L109-L111, core/types/tx_access_list.go:L38-L45, params/protocol_params.go:L100]","IntrinsicGas():L111 adds accessList.StorageKeys() * TxAccessListStorageKeyGas (1900, protocol_params.go:L100). AccessList.StorageKeys():L38-L45 counts total storage keys. Entry: state_transition.go:execute():L446. Enforcement: Storage key cost included in intrinsic gas calculation.",,
EIP2930-OBL-012,fees,gas charging,The access list gas charge MUST occur at the beginning of execution (at the same time as the intrinsic gas is charged according to EIP-2028 rules).,"[transactions.py:L276-L319, fork.py:L638, transactions.py:L268-L270]",Entry point: fork.py:process_transaction():L638 calls validate_transaction() BEFORE execution. validate_transaction():L268-L270 calls calculate_intrinsic_cost() which includes access_list_cost in total intrinsic_gas (L311-L317). Gas deducted from tx.gas at L648 (gas = tx.gas - intrinsic_gas) before message execution.,,,"[core/state_transition.go:L446, core/state_transition.go:L466]","execute():L446 calls IntrinsicGas() which includes access list gas. L466: st.gasRemaining -= gas deducts intrinsic gas BEFORE execution starts. Entry: state_transition.go:execute(). Enforcement: Gas deducted at L466 before vm.Create/Call at L500/L523, ensuring access list charged at execution start.",,
EIP2930-OBL-013,execution semantics,state initialization,Addresses from the access list MUST be immediately loaded into the accessed_addresses global set at the beginning of execution.,"[fork.py:L657-L661, utils/message.py:L49-L52, vm/__init__.py:L90, vm/interpreter.py:L242]",Entry point: fork.py:process_transaction():L657-L663 extracts access_list_addresses from tx.access_list. fork.py:L669 passes to TransactionEnvironment. prepare_message():L49-L52 adds tx_env.access_list_addresses to accessed_addresses. Message created with accessed_addresses (L87). vm/interpreter.py:L242 initializes Evm.accessed_addresses from message.accessed_addresses.,,,"[core/state/statedb.go:L1411-L1433, core/state/statedb.go:L1428-L1429]","StateDB.Prepare():L1411-L1440 initializes access list. L1428-L1429: for each el in accessList, al.AddAddress(el.Address). Entry: state_transition.go:execute():L493 calls state.Prepare(). Enforcement: Access list addresses added to accessList at start of transaction before execution.",,
EIP2930-OBL-014,execution semantics,state initialization,Storage keys from the access list MUST be immediately loaded into the accessed_storage_keys global set at the beginning of execution (as address-key pairs).,"[fork.py:L657-L663, utils/message.py:L88, vm/__init__.py:L91, vm/interpreter.py:L243]","Entry point: fork.py:process_transaction():L657-L663 extracts (account, slot) pairs into access_list_storage_keys. fork.py:L670 passes to TransactionEnvironment. prepare_message():L88 sets accessed_storage_keys from tx_env. vm/interpreter.py:L243 initializes Evm.accessed_storage_keys from message.accessed_storage_keys.",,,"[core/state/statedb.go:L1428-L1432, core/state/access_list.go:L89-L107]","StateDB.Prepare():L1428-L1432 iterates access list, calls al.AddAddress(el.Address) and al.AddSlot(el.Address, key) for each storage key. accessList.AddSlot():L89-L107 stores (address,slot) pair. Entry: state_transition.go:execute():L493. Enforcement: Storage keys loaded into accessed_storage_keys map at transaction start.",,
EIP2930-OBL-015,fees,gas charging,Non-unique addresses and storage keys in the access list MUST be charged for multiple times.,[transactions.py:L311-L317],calculate_intrinsic_cost():L311-L317 iterates over tx.access_list without deduplication. For-loop at L313 processes 'for access in tx.access_list' meaning duplicate addresses are charged. ulen(access.slots) at L316 counts all slots including duplicates. Enforcement: No set() or deduplication applied before gas calculation.,,,[core/state_transition.go:L109-L111],"IntrinsicGas():L109-L111 iterates accessList without deduplication: len(accessList) counts all entries, StorageKeys() sums all keys. Entry: state_transition.go:execute():L446. Enforcement: No set/dedup before counting; duplicate addresses/keys each incur gas cost.",,
EIP2930-OBL-016,fees,implicit exclusion,The access list MUST NOT be charged per-byte fees like transaction data.,"[transactions.py:L298-L305, transactions.py:L311-L317]",calculate_intrinsic_cost():L298-L305 calculates data_cost from tx.data bytes only. L311-L317 calculates access_list_cost separately using fixed per-address and per-key costs. Enforcement: access_list is NOT included in the byte-by-byte iteration at L300-L304; it has its own separate cost calculation.,,,"[core/state_transition.go:L81-L99, core/state_transition.go:L109-L112]","IntrinsicGas():L81-L99 calculates data_gas by iterating tx.Data bytes (zero/non-zero). L109-L112 calculates access_list_cost separately using per-address/per-key constants. Enforcement: Access list gas computed via fixed costs, not byte counting; data iteration at L81-L99 only processes tx.Data, not accessList.",,
EIP2930-OBL-017,block validation,fork activation,Type 1 transactions with access lists MUST only be valid as of FORK_BLOCK 12244000.,[],No explicit block number check visible in berlin/fork.py. The fork mechanism relies on the execution-specs directory structure where different forks have separate implementations.,"Spec requires fork activation at block 12244000, but code uses directory-based fork selection rather than block number checks within code.",No explicit FORK_BLOCK constant or block number validation found in berlin/ directory. Fork activation handled externally by client implementation selecting correct fork module.,"[params/config.go:L56, params/config.go:L781-L783, core/txpool/validation.go:L76-L77]",MainnetConfig.BerlinBlock=12244000 (config.go:L56). ChainConfig.IsBerlin():L781-L783 checks block >= BerlinBlock. ValidateTransaction():L76-L77 rejects non-legacy tx if !rules.IsBerlin. Entry: txpool/validation.go:L61. Enforcement: Type 1 tx rejected before Berlin fork block via IsBerlin check.,,
EIP2930-OBL-018,tx validation,format constraint,The transaction MUST only be valid on networks with the specified chainID.,"[transactions.py:L148, fork.py:L388]","check_transaction() -> recover_sender(chain_id, tx). Entry point: fork.py:L388 passes block_env.chain_id to recover_sender(). For AccessListTransaction at L358-L363, signing_hash_2930(tx) at L362 includes tx.chain_id in hash. If tx.chain_id != block_env.chain_id, signature recovery will fail. Enforcement: Implicit via signature verification - wrong chain_id produces wrong hash, signature won't match, InvalidSignatureError raised.",,"Chain ID validation is implicit via signature verification. No explicit tx.chain_id == block_env.chain_id check found. If sender signed with different chain_id, secp256k1_recover will return wrong address, but no explicit error for chain mismatch.","[core/types/transaction_signing.go:L262-L263, core/types/tx_access_list.go:L131-L144]","modernSigner.Sender():L262-L263 checks tx.ChainId().Cmp(s.chainID) != 0, returns ErrInvalidChainId. sigHash():L131-L144 includes chainID in hash. Entry: types.Sender() called during validation. Enforcement: Explicit chain ID mismatch check at L262-L263; also implicit via signature verification with chainID in hash.",,
EIP2930-OBL-019,tx validation,format constraint,YParity MUST be 0 for even or 1 for odd y-value of the secp256k1 signature.,"[transactions.py:L359-L360, transactions.py:L191]","recover_sender() for AccessListTransaction. Entry point: fork.py:check_transaction():L388 -> recover_sender() -> transactions.py:L358-L363. Enforcement: L359-L360 checks 'if tx.y_parity not in (U256(0), U256(1)): raise InvalidSignatureError(""bad y_parity"")'. y_parity field defined at L191.",,,"[crypto/crypto.go:L240-L251, core/types/transaction_signing.go:L267-L269]","modernSigner.Sender():L267-L268 gets V from tx, adds 27 (V = new(big.Int).Add(V, big.NewInt(27))). recoverPlain():L482 converts V back (V := byte(Vb.Uint64() - 27)). ValidateSignatureValues():L250 checks (v == 0 || v == 1). Entry: types.Sender(). Enforcement: V must be 0 or 1 after adjustment; ValidateSignatureValues rejects other values.",,
